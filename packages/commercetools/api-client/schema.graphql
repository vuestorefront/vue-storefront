schema {
  query: Query
  mutation: Mutation
}
"""API Clients can be used to obtain OAuth 2 access tokens. The secret is only shown once in the response of creating the API Client."""
type APIClientWithSecret {
  id: String!
  name: String!
  scope: String!
  createdAt: DateTime
  lastUsedAt: Date
  secret: String!
}
type AWSLambdaDestination implements ExtensionDestination {
  arn: String!
  accessKey: String!
  accessSecret: String!
  type: String!
}
input AWSLambdaDestinationInput {
  arn: String!
  accessKey: String!
  accessSecret: String!
}
type AbsoluteDiscountValue implements CartDiscountValue& ProductDiscountValue {
  money: [Money!]!
  type: String!
}
input AbsoluteDiscountValueInput {
  money: [MoneyInput!]!
}
input AddCartCustomLineItem {
  shippingDetails: ItemShippingDetailsDraft
  custom: CustomFieldsDraft
  quantity: Long
  externalTaxRate: ExternalTaxRateDraft
  taxCategory: ResourceIdentifierInput
  slug: String!
  money: BaseMoneyInput!
  name: [LocalizedStringItemInputType!]!
}
input AddCartDiscountCode {
  code: String!
  validateDuplicates: Boolean = false
}
input AddCartItemShippingAddress {
  address: AddressInput!
}
input AddCartLineItem {
  addedAt: DateTime
  shippingDetails: ItemShippingDetailsDraft
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  externalPrice: BaseMoneyInput
  externalTaxRate: ExternalTaxRateDraft
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  supplyChannel: ResourceIdentifierInput
  variantId: Int
  quantity: Long
  sku: String
  productId: String
}
input AddCartPayment {
  payment: ResourceIdentifierInput!
}
input AddCartShoppingList {
  shoppingList: ResourceIdentifierInput!
  supplyChannel: ResourceIdentifierInput
  distributionChannel: ResourceIdentifierInput
}
input AddCategoryAsset {
  position: Int
  asset: AssetDraftInput!
}
input AddChannelRoles {
  roles: [ChannelRole!]!
}
input AddCustomerAddress {
  address: AddressInput!
}
input AddCustomerBillingAddressId {
  addressId: String
  addressKey: String
}
input AddCustomerShippingAddressId {
  addressId: String
  addressKey: String
}
input AddCustomerStore {
  store: ResourceIdentifierInput!
}
input AddInventoryEntryQuantity {
  quantity: Long!
}
input AddMyCartLineItem {
  addedAt: DateTime
  shippingDetails: ItemShippingDetailsDraft
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  supplyChannel: ResourceIdentifierInput
  variantId: Int
  quantity: Long
  sku: String
  productId: String
}
input AddMyPaymentTransaction {
  transaction: MyTransactionDraft!
}
input AddOrderDelivery {
  items: [DeliveryItemDraftType!] = []
  parcels: [ParcelDataDraftType!] = []
  address: AddressInput
}
input AddOrderEditStagedAction {
  stagedAction: StagedOrderUpdateAction!
}
input AddOrderItemShippingAddress {
  address: AddressInput!
}
input AddOrderParcelToDelivery {
  deliveryId: String!
  measurements: ParcelMeasurementsDraftType
  trackingData: TrackingDataDraftType
  items: [DeliveryItemDraftType!] = []
}
input AddOrderPayment {
  payment: ResourceIdentifierInput!
}
input AddOrderReturnInfo {
  items: [ReturnItemDraftType!]!
  returnDate: DateTime
  returnTrackingId: String
}
input AddPaymentInterfaceInteraction {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input AddPaymentTransaction {
  transaction: TransactionDraft!
}
input AddProductAsset {
  variantId: Int
  sku: String
  staged: Boolean = true
  position: Int
  asset: AssetDraftInput!
}
input AddProductExternalImage {
  variantId: Int
  sku: String
  image: ImageInput!
  staged: Boolean = true
}
input AddProductPrice {
  variantId: Int
  sku: String
  price: ProductPriceDataInput!
  staged: Boolean = true
}
input AddProductToCategory {
  category: ResourceIdentifierInput!
  orderHint: String
  staged: Boolean = true
}
input AddProductVariant {
  assets: [AssetDraftInput!] = []
  attributes: [ProductAttributeInput!] = []
  images: [ImageInput!] = []
  prices: [ProductPriceDataInput!] = []
  key: String
  sku: String
  staged: Boolean = true
}
input AddShippingMethodShippingRate {
  zone: ResourceIdentifierInput!
  shippingRate: ShippingRateDraft!
}
input AddShippingMethodZone {
  zone: ResourceIdentifierInput!
}
input AddShoppingListLineItem {
  addedAt: DateTime
  custom: CustomFieldsDraft
  quantity: Int = 1
  variantId: Int
  sku: String
  productId: String
}
input AddShoppingListTextLineItem {
  addedAt: DateTime
  custom: CustomFieldsDraft
  quantity: Int = 1
  description: [LocalizedStringItemInputType!]
  name: [LocalizedStringItemInputType!]!
}
input AddStagedOrderCustomLineItem {
  shippingDetails: ItemShippingDetailsDraftType
  custom: CustomFieldsDraft
  quantity: Long
  externalTaxRate: ExternalTaxRateDraft
  taxCategory: ResourceIdentifierInput
  slug: String!
  money: BaseMoneyInput!
  name: [LocalizedStringItemInputType!]!
}
type AddStagedOrderCustomLineItemOutput implements StagedOrderUpdateActionOutput {
  type: String!
  draft: CustomLineItemDraftOutput!
}
input AddStagedOrderDelivery {
  items: [DeliveryItemDraftType!] = []
  parcels: [ParcelDataDraftType!] = []
  address: AddressInput
}
type AddStagedOrderDeliveryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  items: [DeliveryItem!]!
  parcels: [ParcelData!]!
  address: AddressDraft
}
input AddStagedOrderDiscountCode {
  code: String!
  validateDuplicates: Boolean = false
}
type AddStagedOrderDiscountCodeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  code: String!
  validateDuplicates: Boolean!
}
input AddStagedOrderItemShippingAddress {
  address: AddressInput!
}
type AddStagedOrderItemShippingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft!
}
input AddStagedOrderLineItem {
  addedAt: DateTime
  shippingDetails: ItemShippingDetailsDraftType
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  externalPrice: BaseMoneyInput
  externalTaxRate: ExternalTaxRateDraft
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  supplyChannel: ResourceIdentifierInput
  variantId: Int
  quantity: Long
  sku: String
  productId: String
}
type AddStagedOrderLineItemOutput implements StagedOrderUpdateActionOutput {
  type: String!
  draft: LineItemDraftOutput!
}
input AddStagedOrderParcelToDelivery {
  deliveryId: String!
  measurements: ParcelMeasurementsDraftType
  trackingData: TrackingDataDraftType
  items: [DeliveryItemDraftType!] = []
}
type AddStagedOrderParcelToDeliveryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String!
  measurements: ParcelMeasurements
  trackingData: TrackingData
  items: [DeliveryItem!]!
}
input AddStagedOrderPayment {
  payment: ResourceIdentifierInput!
}
type AddStagedOrderPaymentOutput implements StagedOrderUpdateActionOutput {
  type: String!
  paymentResId: ResourceIdentifier!
}
input AddStagedOrderReturnInfo {
  items: [ReturnItemDraftType!]!
  returnDate: DateTime
  returnTrackingId: String
}
type AddStagedOrderReturnInfoOutput implements StagedOrderUpdateActionOutput {
  type: String!
  items: [ReturnItemDraftTypeOutput!]!
  returnDate: DateTime
  returnTrackingId: String
}
input AddStagedOrderShoppingList {
  shoppingList: ResourceIdentifierInput!
  supplyChannel: ResourceIdentifierInput
  distributionChannel: ResourceIdentifierInput
}
type AddStagedOrderShoppingListOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shoppingListResId: ResourceIdentifier!
  supplyChannelResId: ChannelReferenceIdentifier
  distributionChannelResId: ChannelReferenceIdentifier
}
input AddStateRoles {
  roles: [StateRole!]!
}
input AddStoreDistributionChannel {
  distributionChannel: ResourceIdentifierInput!
}
input AddStoreSupplyChannel {
  supplyChannel: ResourceIdentifierInput!
}
input AddTypeEnumValue {
  fieldName: String!
  value: EnumValueInput!
}
input AddTypeFieldDefinition {
  fieldDefinition: FieldDefinitionInput!
}
input AddTypeLocalizedEnumValue {
  fieldName: String!
  value: LocalizedEnumValueInput!
}
input AddZoneLocation {
  location: ZoneLocation!
}
type AddressDraft {
  id: String
  streetName: String
  streetNumber: String
  additionalStreetInfo: String
  postalCode: String
  city: String
  region: String
  state: String
  country: Country!
  company: String
  department: String
  building: String
  apartment: String
  pOBox: String
  additionalAddressInfo: String
  externalId: String
  key: String
  custom: CustomFieldsCommand
  phone: String
  mobile: String
  email: String
  fax: String
  title: String
  salutation: String
  firstName: String
  lastName: String
}
input AddressInput {
  id: String
  title: String
  salutation: String
  firstName: String
  lastName: String
  streetName: String
  streetNumber: String
  additionalStreetInfo: String
  postalCode: String
  city: String
  region: String
  state: String
  country: Country!
  company: String
  department: String
  building: String
  apartment: String
  pOBox: String
  phone: String
  mobile: String
  email: String
  fax: String
  additionalAddressInfo: String
  externalId: String
  key: String
  custom: CustomFieldsDraft
}
enum AnonymousCartSignInMode {
  """The anonymous cart is used as new active customer cart. No `LineItem`s get merged."""
  UseAsNewActiveCustomerCart
  """
  `LineItem`s of the anonymous cart will be copied to the customer’s active cart that has been modified most recently.

The `CartState` of the anonymous cart gets changed to `Merged` while the `CartState` of the customer’s cart remains `Active`.

`CustomLineItems` and `CustomFields` of the anonymous cart will not be copied to the customers cart.

If a `LineItem` in the anonymous cart matches an existing line item in the customer’s cart (same product ID and variant ID), the maximum quantity of both LineItems is used as the new quantity. In that case `CustomFields` on the `LineItem` of the anonymous cart will not be in the resulting `LineItem`.
  """
  MergeWithExistingCustomerCart
}
type Applied implements OrderEditResult {
  appliedAt: DateTime!
  excerptBeforeEdit: OrderExcerpt!
  excerptAfterEdit: OrderExcerpt!
  type: String!
}
input ApplyCartDeltaToCustomLineItemShippingDetailsTargets {
  customLineItemId: String!
  targetsDelta: [ShippingTargetDraft!]!
}
input ApplyCartDeltaToLineItemShippingDetailsTargets {
  lineItemId: String!
  targetsDelta: [ShippingTargetDraft!]!
}
input AssetDimensionsInput {
  width: Int!
  height: Int!
}
input AssetDraftInput {
  key: String
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  custom: CustomFieldsDraft
  sources: [AssetSourceInput!]
  tags: [String!]
  type: ResourceIdentifierInput
}
input AssetSourceInput {
  uri: String!
  key: String
  dimensions: AssetDimensionsInput
  contentType: String
}
interface Attribute {
  name: String!
}
input AttributeDefinitionDraft {
  type: AttributeTypeDraft!
  name: String!
  label: [LocalizedStringItemInputType!]!
  isRequired: Boolean!
  attributeConstraint: AttributeConstraint
  inputTip: [LocalizedStringItemInputType!]
  inputHint: TextInputHint
  isSearchable: Boolean!
}
input AttributeSetElementTypeDraft {
  text: SimpleAttributeTypeDraft
  number: SimpleAttributeTypeDraft
  money: SimpleAttributeTypeDraft
  date: SimpleAttributeTypeDraft
  time: SimpleAttributeTypeDraft
  datetime: SimpleAttributeTypeDraft
  boolean: SimpleAttributeTypeDraft
  reference: ReferenceTypeDefinitionDraft
  enum: EnumTypeDraft
  lenum: LocalizableEnumTypeDraft
  ltext: SimpleAttributeTypeDraft
}
input AttributeSetTypeDraft {
  elementType: AttributeSetElementTypeDraft!
}
input AttributeTypeDraft {
  set: AttributeSetTypeDraft
  text: SimpleAttributeTypeDraft
  number: SimpleAttributeTypeDraft
  money: SimpleAttributeTypeDraft
  date: SimpleAttributeTypeDraft
  time: SimpleAttributeTypeDraft
  datetime: SimpleAttributeTypeDraft
  boolean: SimpleAttributeTypeDraft
  reference: ReferenceTypeDefinitionDraft
  enum: EnumTypeDraft
  lenum: LocalizableEnumTypeDraft
  ltext: SimpleAttributeTypeDraft
}
type AuthorizationHeader implements HttpDestinationAuthentication {
  headerValue: String!
  type: String!
}
input AuthorizationHeaderInput {
  headerValue: String!
}
type AzureFunctionsAuthentication implements HttpDestinationAuthentication {
  key: String!
  type: String!
}
input AzureFunctionsAuthenticationInput {
  key: String!
}
type AzureServiceBusDestination implements Destination {
  connectionString: String!
  type: String!
}
input AzureServiceBusDestinationInput {
  connectionString: String!
}
input BaseMoneyInput {
  centPrecision: MoneyInput
  highPrecision: HighPrecisionMoneyInput
}
input BaseSearchKeywordInput {
  whitespace: WhitespaceSuggestTokenizerInput
  custom: CustomSuggestTokenizerInput
}
type BooleanAttribute implements Attribute {
  value: Boolean!
  name: String!
}
type BooleanField implements CustomField {
  value: Boolean!
  name: String!
}
type BooleanType implements FieldType {
  name: String!
}
input CartClassificationInput {
  values: [LocalizedEnumValueInput!]!
}
type CartClassificationType implements ShippingRateInputType {
  values: [ShippingRateInputLocalizedEnumValue!]!
  type: String!
}
type CartCreated implements MessagePayload {
  totalPrice: Money!
  lineItemCount: Int!
  discountCodesRefs: [Reference!]!
  type: String!
}
input CartDiscountDraft {
  value: CartDiscountValueInput!
  cartPredicate: String!
  target: CartDiscountTargetInput
  sortOrder: String!
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  validFrom: DateTime
  validUntil: DateTime
  stackingMode: StackingMode = Stacking
  requiresDiscountCode: Boolean = false
  isActive: Boolean = true
  custom: CustomFieldsDraft
  key: String
}
input CartDiscountTargetInput {
  lineItems: LineItemsTargetInput
  customLineItems: CustomLineItemsTargetInput
  shipping: ShippingTargetInput
  multiBuyLineItems: MultiBuyLineItemsTargetInput
  multiBuyCustomLineItems: MultiBuyCustomLineItemsTargetInput
}
input CartDiscountUpdateAction {
  changeCartPredicate: ChangeCartDiscountCartPredicate
  changeIsActive: ChangeCartDiscountIsActive
  changeName: ChangeCartDiscountName
  changeRequiresDiscountCode: ChangeCartDiscountRequiresDiscountCode
  changeSortOrder: ChangeCartDiscountSortOrder
  changeStackingMode: ChangeCartDiscountStackingMode
  changeTarget: ChangeCartDiscountTarget
  changeValue: ChangeCartDiscountValue
  setCustomField: SetCartDiscountCustomField
  setCustomType: SetCartDiscountCustomType
  setDescription: SetCartDiscountDescription
  setKey: SetCartDiscountKey
  setValidFrom: SetCartDiscountValidFrom
  setValidFromAndUntil: SetCartDiscountValidFromAndUntil
  setValidUntil: SetCartDiscountValidUntil
}
input CartDiscountValueInput {
  relative: RelativeDiscountValueInput
  absolute: AbsoluteDiscountValueInput
  fixed: FixedPriceDiscountValueInput
  giftLineItem: GiftLineItemValueInput
}
input CartDraft {
  currency: Currency!
  country: Country
  inventoryMode: InventoryMode = None
  custom: CustomFieldsDraft
  customerEmail: String
  shippingAddress: AddressInput
  billingAddress: AddressInput
  shippingMethod: ResourceIdentifierInput
  taxMode: TaxMode = Platform
  locale: Locale
  deleteDaysAfterLastModification: Int
  itemShippingAddresses: [AddressInput!] = []
  discountCodes: [String!] = []
  store: ResourceIdentifierInput
  key: String
  lineItems: [LineItemDraft!] = []
  customLineItems: [CustomLineItemDraft!] = []
  customerId: String
  externalTaxRateForShippingMethod: ExternalTaxRateDraft
  anonymousId: String
  taxRoundingMode: RoundingMode = HalfEven
  taxCalculationMode: TaxCalculationMode = LineItemLevel
  customerGroup: ResourceIdentifierInput
  shippingRateInput: ShippingRateInputDraft
  origin: CartOrigin = Customer
}
input CartScoreInput {
  dummy: String
}
type CartScoreType implements ShippingRateInputType {
  type: String!
}
input CartUpdateAction {
  addCustomLineItem: AddCartCustomLineItem
  addDiscountCode: AddCartDiscountCode
  addItemShippingAddress: AddCartItemShippingAddress
  addLineItem: AddCartLineItem
  addPayment: AddCartPayment
  addShoppingList: AddCartShoppingList
  applyDeltaToCustomLineItemShippingDetailsTargets: ApplyCartDeltaToCustomLineItemShippingDetailsTargets
  applyDeltaToLineItemShippingDetailsTargets: ApplyCartDeltaToLineItemShippingDetailsTargets
  changeCustomLineItemMoney: ChangeCartCustomLineItemMoney
  changeCustomLineItemQuantity: ChangeCartCustomLineItemQuantity
  changeLineItemQuantity: ChangeCartLineItemQuantity
  changeTaxCalculationMode: ChangeCartTaxCalculationMode
  changeTaxMode: ChangeCartTaxMode
  changeTaxRoundingMode: ChangeCartTaxRoundingMode
  recalculate: RecalculateCart
  removeCustomLineItem: RemoveCartCustomLineItem
  removeDiscountCode: RemoveCartDiscountCode
  removeItemShippingAddress: RemoveCartItemShippingAddress
  removeLineItem: RemoveCartLineItem
  removePayment: RemoveCartPayment
  setAnonymousId: SetCartAnonymousId
  setBillingAddress: SetCartBillingAddress
  setBillingAddressCustomField: SetCartBillingAddressCustomField
  setBillingAddressCustomType: SetCartBillingAddressCustomType
  setKey: SetCartKey
  setCartTotalTax: SetCartTotalTax
  setCountry: SetCartCountry
  setCustomField: SetCartCustomField
  setCustomLineItemCustomField: SetCartCustomLineItemCustomField
  setCustomLineItemCustomType: SetCartCustomLineItemCustomType
  setCustomLineItemShippingDetails: SetCartCustomLineItemShippingDetails
  setCustomLineItemTaxAmount: SetCartCustomLineItemTaxAmount
  setCustomLineItemTaxRate: SetCartCustomLineItemTaxRate
  setCustomShippingMethod: SetCartCustomShippingMethod
  setCustomType: SetCartCustomType
  setCustomerEmail: SetCartCustomerEmail
  setCustomerGroup: SetCartCustomerGroup
  setCustomerId: SetCartCustomerId
  setDeleteDaysAfterLastModification: SetCartDeleteDaysAfterLastModification
  setItemShippingAddressCustomField: SetCartItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetCartItemShippingAddressCustomType
  setLineItemCustomField: SetCartLineItemCustomField
  setLineItemCustomType: SetCartLineItemCustomType
  setLineItemDistributionChannel: SetCartLineItemDistributionChannel
  setLineItemPrice: SetCartLineItemPrice
  setLineItemShippingDetails: SetCartLineItemShippingDetails
  setLineItemTaxAmount: SetCartLineItemTaxAmount
  setLineItemTaxRate: SetCartLineItemTaxRate
  setLineItemTotalPrice: SetCartLineItemTotalPrice
  setLocale: SetCartLocale
  setShippingAddress: SetCartShippingAddress
  setShippingAddressCustomField: SetCartShippingAddressCustomField
  setShippingAddressCustomType: SetCartShippingAddressCustomType
  setShippingMethod: SetCartShippingMethod
  setShippingMethodTaxAmount: SetCartShippingMethodTaxAmount
  setShippingMethodTaxRate: SetCartShippingMethodTaxRate
  setShippingRateInput: SetCartShippingRateInput
  updateItemShippingAddress: UpdateCartItemShippingAddress
}
input CartValueInput {
  dummy: String
}
type CartValueType implements ShippingRateInputType {
  type: String!
}
input CartsConfigurationInput {
  deleteDaysAfterLastModification: Int
}
type CategoryCreated implements MessagePayload {
  category: Category!
  type: String!
}
input CategoryDraft {
  key: String
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  custom: CustomFieldsDraft
  slug: [LocalizedStringItemInputType!]!
  externalId: String
  metaTitle: [LocalizedStringItemInputType!]
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  orderHint: String
  parent: ResourceIdentifierInput
  assets: [AssetDraftInput!] = []
}
input CategoryOrderHintInput {
  uuid: String!
  orderHint: String!
}
type CategorySlugChanged implements MessagePayload {
  slug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  oldSlug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  oldSlugAllLocales: [LocalizedString!]
  type: String!
}
input CategoryUpdateAction {
  addAsset: AddCategoryAsset
  changeAssetName: ChangeCategoryAssetName
  changeAssetOrder: ChangeCategoryAssetOrder
  changeName: ChangeCategoryName
  changeOrderHint: ChangeCategoryOrderHint
  changeSlug: ChangeCategorySlug
  changeParent: ChangeCategoryParent
  removeAsset: RemoveCategoryAsset
  setAssetCustomField: SetCategoryAssetCustomField
  setAssetCustomType: SetCategoryAssetCustomType
  setAssetDescription: SetCategoryAssetDescription
  setAssetKey: SetCategoryAssetKey
  setAssetSources: SetCategoryAssetSources
  setAssetTags: SetCategoryAssetTags
  setCustomField: SetCategoryCustomField
  setCustomType: SetCategoryCustomType
  setDescription: SetCategoryDescription
  setKey: SetCategoryKey
  setMetaDescription: SetCategoryMetaDescription
  setMetaKeywords: SetCategoryMetaKeywords
  setMetaTitle: SetCategoryMetaTitle
  setExternalId: SetCategoryExternalId
}
input ChangeCartCustomLineItemMoney {
  customLineItemId: String!
  money: BaseMoneyInput!
}
input ChangeCartCustomLineItemQuantity {
  customLineItemId: String!
  quantity: Long!
}
input ChangeCartDiscountCartPredicate {
  cartPredicate: String!
}
input ChangeCartDiscountIsActive {
  isActive: Boolean!
}
input ChangeCartDiscountName {
  name: [LocalizedStringItemInputType!]!
}
input ChangeCartDiscountRequiresDiscountCode {
  requiresDiscountCode: Boolean!
}
input ChangeCartDiscountSortOrder {
  sortOrder: String!
}
input ChangeCartDiscountStackingMode {
  stackingMode: StackingMode!
}
input ChangeCartDiscountTarget {
  target: CartDiscountTargetInput!
}
input ChangeCartDiscountValue {
  value: CartDiscountValueInput!
}
input ChangeCartLineItemQuantity {
  lineItemId: String!
  quantity: Long!
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
}
input ChangeCartTaxCalculationMode {
  taxCalculationMode: TaxCalculationMode!
}
input ChangeCartTaxMode {
  taxMode: TaxMode!
}
input ChangeCartTaxRoundingMode {
  taxRoundingMode: RoundingMode!
}
input ChangeCategoryAssetName {
  name: [LocalizedStringItemInputType!]!
  assetKey: String
  assetId: String
}
input ChangeCategoryAssetOrder {
  assetOrder: [String!]!
}
input ChangeCategoryName {
  name: [LocalizedStringItemInputType!]!
}
input ChangeCategoryOrderHint {
  orderHint: String!
}
input ChangeCategoryParent {
  parent: ResourceIdentifierInput!
}
input ChangeCategorySlug {
  slug: [LocalizedStringItemInputType!]!
}
input ChangeChannelDescription {
  description: [LocalizedStringItemInputType!]
}
input ChangeChannelKey {
  key: String!
}
input ChangeChannelName {
  name: [LocalizedStringItemInputType!]
}
input ChangeCustomerAddress {
  addressId: String
  addressKey: String
  address: AddressInput!
}
input ChangeCustomerEmail {
  email: String!
}
input ChangeCustomerGroupName {
  name: String!
}
input ChangeDiscountCodeCartDiscounts {
  cartDiscounts: [ReferenceInput!]!
}
input ChangeDiscountCodeGroups {
  groups: [String!]!
}
input ChangeDiscountCodeIsActive {
  isActive: Boolean!
}
input ChangeExtensionDestination {
  destination: ExtensionDestinationInput!
}
input ChangeExtensionTriggers {
  triggers: [TriggerInput!]!
}
input ChangeInventoryEntryQuantity {
  quantity: Long!
}
input ChangeMyCartTaxMode {
  taxMode: TaxMode!
}
input ChangeOrderPaymentState {
  paymentState: PaymentState!
}
input ChangeOrderShipmentState {
  shipmentState: ShipmentState!
}
input ChangeOrderState {
  orderState: OrderState!
}
input ChangePaymentAmountPlanned {
  amount: MoneyInput!
}
input ChangePaymentTransactionInteractionId {
  transactionId: String!
  interactionId: String!
}
input ChangePaymentTransactionState {
  transactionId: String!
  state: TransactionState!
}
input ChangePaymentTransactionTimestamp {
  transactionId: String!
  timestamp: DateTime!
}
input ChangeProductAssetName {
  variantId: Int
  sku: String
  staged: Boolean = true
  name: [LocalizedStringItemInputType!]!
  assetKey: String
  assetId: String
}
input ChangeProductAssetOrder {
  variantId: Int
  sku: String
  staged: Boolean = true
  assetOrder: [String!]!
}
input ChangeProductDiscountIsActive {
  isActive: Boolean!
}
input ChangeProductDiscountName {
  name: [LocalizedStringItemInputType!]!
}
input ChangeProductDiscountPredicate {
  predicate: String!
}
input ChangeProductDiscountSortOrder {
  sortOrder: String!
}
input ChangeProductDiscountValue {
  value: ProductDiscountValueInput!
}
input ChangeProductImageLabel {
  variantId: Int
  sku: String
  imageUrl: String!
  label: String
  staged: Boolean = true
}
input ChangeProductMasterVariant {
  variantId: Int
  sku: String
  staged: Boolean = true
}
input ChangeProductName {
  name: [LocalizedStringItemInputType!]!
  staged: Boolean = true
}
input ChangeProductPrice {
  priceId: String
  variantId: Int
  sku: String
  price: ProductPriceDataInput!
  staged: Boolean = true
}
input ChangeProductSlug {
  slug: [LocalizedStringItemInputType!]!
  staged: Boolean = true
}
input ChangeProjectSettingsCartsConfiguration {
  cartsConfiguration: CartsConfigurationInput!
}
input ChangeProjectSettingsCountries {
  countries: [Country!]!
}
input ChangeProjectSettingsCountryTaxRateFallbackEnabled {
  countryTaxRateFallbackEnabled: Boolean!
}
input ChangeProjectSettingsCurrencies {
  currencies: [Currency!]!
}
input ChangeProjectSettingsLanguages {
  languages: [Locale!]!
}
input ChangeProjectSettingsMessagesConfiguration {
  messagesConfiguration: MessagesConfigurationDraft!
}
input ChangeProjectSettingsMessagesEnabled {
  messagesEnabled: Boolean!
}
input ChangeProjectSettingsName {
  name: String!
}
input ChangeProjectSettingsOrderSearchStatus {
  status: OrderSearchStatus!
}
input ChangeProjectSettingsProductSearchIndexingEnabled {
  enabled: Boolean!
}
input ChangeProjectSettingsShoppingListsConfiguration {
  shoppingListsConfiguration: ShoppingListsConfigurationInput!
}
input ChangeShippingMethodIsDefault {
  isDefault: Boolean!
}
input ChangeShippingMethodName {
  name: String!
}
input ChangeShippingMethodTaxCategory {
  taxCategory: ResourceIdentifierInput!
}
input ChangeShoppingListLineItemQuantity {
  lineItemId: String!
  quantity: Int!
}
input ChangeShoppingListLineItemsOrder {
  lineItemOrder: [String!]!
}
input ChangeShoppingListName {
  name: [LocalizedStringItemInputType!]!
}
input ChangeShoppingListTextLineItemName {
  textLineItemId: String!
  name: [LocalizedStringItemInputType!]!
}
input ChangeShoppingListTextLineItemQuantity {
  textLineItemId: String!
  quantity: Int!
}
input ChangeShoppingListTextLineItemsOrder {
  textLineItemOrder: [String!]!
}
input ChangeStagedOrderCustomLineItemMoney {
  customLineItemId: String!
  money: BaseMoneyInput!
}
type ChangeStagedOrderCustomLineItemMoneyOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
  money: BaseMoney!
}
input ChangeStagedOrderCustomLineItemQuantity {
  customLineItemId: String!
  quantity: Long!
}
type ChangeStagedOrderCustomLineItemQuantityOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
  quantity: Long!
}
input ChangeStagedOrderLineItemQuantity {
  lineItemId: String!
  quantity: Long!
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
}
type ChangeStagedOrderLineItemQuantityOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  quantity: Long!
  externalPrice: BaseMoney
  externalTotalPrice: ExternalLineItemTotalPrice
}
input ChangeStagedOrderOrderState {
  orderState: OrderState!
}
type ChangeStagedOrderOrderStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  orderState: OrderState!
}
input ChangeStagedOrderPaymentState {
  paymentState: PaymentState!
}
type ChangeStagedOrderPaymentStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  paymentState: PaymentState!
}
input ChangeStagedOrderShipmentState {
  shipmentState: ShipmentState!
}
type ChangeStagedOrderShipmentStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shipmentState: ShipmentState!
}
input ChangeStagedOrderTaxCalculationMode {
  taxCalculationMode: TaxCalculationMode!
}
type ChangeStagedOrderTaxCalculationModeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  taxCalculationMode: TaxCalculationMode!
}
input ChangeStagedOrderTaxMode {
  taxMode: TaxMode!
}
type ChangeStagedOrderTaxModeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  taxMode: TaxMode!
}
input ChangeStagedOrderTaxRoundingMode {
  taxRoundingMode: RoundingMode!
}
type ChangeStagedOrderTaxRoundingModeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  taxRoundingMode: RoundingMode!
}
input ChangeStateInitial {
  initial: Boolean!
}
input ChangeStateKey {
  key: String!
}
input ChangeStateType {
  type: StateType!
}
input ChangeSubscriptionDestination {
  destination: DestinationInput!
}
input ChangeSubscriptionInput {
  resourceTypeId: String!
}
input ChangeTypeEnumValueLabel {
  fieldName: String!
  value: EnumValueInput!
}
input ChangeTypeEnumValueOrder {
  fieldName: String!
  keys: [String!]!
}
input ChangeTypeFieldDefinitionOrder {
  fieldNames: [String!]!
}
input ChangeTypeInputHint {
  fieldName: String!
  inputHint: TextInputHint!
}
input ChangeTypeKey {
  key: String!
}
input ChangeTypeLabel {
  fieldName: String!
  label: [LocalizedStringItemInputType!]!
}
input ChangeTypeLocalizedEnumValueLabel {
  fieldName: String!
  value: LocalizedEnumValueInput!
}
input ChangeTypeLocalizedEnumValueOrder {
  fieldName: String!
  keys: [String!]!
}
input ChangeTypeName {
  name: [LocalizedStringItemInputType!]!
}
input ChangeZoneName {
  name: String!
}
input ChannelDraft {
  key: String!
  roles: [ChannelRole!]!
  name: [LocalizedStringItemInputType!]
  description: [LocalizedStringItemInputType!]
  custom: CustomFieldsDraft
  address: AddressInput
  geoLocation: GeometryInput
}
type ChannelReferenceIdentifier {
  typeId: String!
  id: String
  key: String
}
input ChannelUpdateAction {
  addRoles: AddChannelRoles
  changeDescription: ChangeChannelDescription
  changeKey: ChangeChannelKey
  changeName: ChangeChannelName
  removeRoles: RemoveChannelRoles
  setAddress: SetChannelAddress
  setAddressCustomField: SetChannelAddressCustomField
  setAddressCustomType: SetChannelAddressCustomType
  setCustomField: SetChannelCustomField
  setCustomType: SetChannelCustomType
  setGeoLocation: SetChannelGeoLocation
  setRoles: SetChannelRoles
}
type ClassificationShippingRateInput implements ShippingRateInput {
  key: String!
  type: String!
  labelAllLocales: [LocalizedString!]!
  label("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
}
input ClassificationShippingRateInputDraft {
  key: String!
}
type ClassificationShippingRateInputDraftOutput implements ShippingRateInputDraftOutput {
  key: String!
  type: String!
}
type CloudEventsSubscriptionsFormat implements NotificationFormat {
  type: String!
  cloudEventsVersion: String!
}
input CloudEventsSubscriptionsFormatInput {
  cloudEventsVersion: String!
}
input CreateApiClient {
  name: String!
  scope: String!
}
input CreateStore {
  key: String!
  name: [LocalizedStringItemInputType!]
  languages: [Locale!]
  distributionChannels: [ResourceIdentifierInput!]
  supplyChannels: [ResourceIdentifierInput!]
  custom: CustomFieldsDraft
}
input CreateZone {
  name: String!
  key: String
  description: String
  locations: [ZoneLocation!] = []
}
interface CustomField {
  name: String!
}
"""
A key-value pair representing the field name and value of one single custom field.

The value of this custom field consists of escaped JSON based on the FieldDefinition of the Type.

Examples for `value`:

* FieldType `String`: `"\"This is a string\""`
* FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
* FieldType `Number`: `"4"`
* FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
* FieldType `Reference`: `"{\"id\", \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\", \"product\"}"`
"""
input CustomFieldInput {
  name: String!
  """
  The value of this custom field consists of escaped JSON based on the FieldDefinition of the Type.

Examples for `value`:

* FieldType `String`: `"\"This is a string\""`
* FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
* FieldType `Number`: `"4"`
* FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
* FieldType `Reference`: `"{\"id\", \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\", \"product\"}"`
  """
  value: String!
}
type CustomFieldsCommand {
  typeId: String
  typeKey: String
  fields: Json!
  typeResId: ResourceIdentifier
}
input CustomFieldsDraft {
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
}
input CustomLineItemDraft {
  name: [LocalizedStringItemInputType!]!
  money: BaseMoneyInput!
  slug: String!
  taxCategory: ReferenceInput
  externalTaxRate: ExternalTaxRateDraft
  quantity: Long
  custom: CustomFieldsDraft
  shippingDetails: ItemShippingDetailsDraft
}
type CustomLineItemDraftOutput {
  money: BaseMoney!
  slug: String!
  externalTaxRate: ExternalTaxRateDraftOutput
  quantity: Long
  custom: CustomFieldsCommand
  shippingDetails: ItemShippingDetailsDraftOutput
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  taxCategoryResId: ResourceIdentifier
  nameAllLocales: [LocalizedString!]!
}
type CustomLineItemReturnItem implements ReturnItem {
  type: String!
  customLineItemId: String!
  id: String!
  quantity: Long!
  comment: String
  shipmentState: ReturnShipmentState!
  paymentState: ReturnPaymentState!
  lastModifiedAt: DateTime!
  createdAt: DateTime!
}
type CustomLineItemStateTransition implements MessagePayload {
  customLineItemId: String!
  transitionDate: DateTime!
  quantity: Long!
  fromState: State
  toState: State
  fromStateRef: Reference!
  toStateRef: Reference!
  type: String!
}
type CustomLineItemsTarget implements CartDiscountTarget {
  predicate: String!
  type: String!
}
input CustomLineItemsTargetInput {
  predicate: String!
}
input CustomObjectDraft {
  key: String!
  container: String!
  """The value should be passed in a form of escaped JSON"""
  value: String!
  version: Long
}
type CustomSuggestTokenizer implements SuggestTokenizer {
  inputs: [String!]!
  type: String!
}
input CustomSuggestTokenizerInput {
  inputs: [String!]!
}
type CustomSuggestTokenizerProductSearch implements SuggestTokenizerProductSearch {
  inputs: [String!]!
  type: String!
}
type CustomerAddressAdded implements MessagePayload {
  address: Address!
  type: String!
}
type CustomerAddressChanged implements MessagePayload {
  address: Address!
  type: String!
}
type CustomerAddressRemoved implements MessagePayload {
  address: Address!
  type: String!
}
type CustomerCompanyNameSet implements MessagePayload {
  companyName: String
  type: String!
}
type CustomerCreated implements MessagePayload {
  customer: Customer!
  type: String!
}
type CustomerDateOfBirthSet implements MessagePayload {
  dateOfBirth: Date
  type: String!
}
type CustomerDeleted implements MessagePayload {
  type: String!
}
type CustomerEmailChanged implements MessagePayload {
  email: String!
  type: String!
}
type CustomerEmailToken implements Versioned {
  customerId: String!
  expiresAt: DateTime!
  value: String!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type CustomerEmailVerified implements MessagePayload {
  type: String!
}
input CustomerGroupDraft {
  groupName: String!
  key: String
  custom: CustomFieldsDraft
}
type CustomerGroupReferenceIdentifier {
  typeId: String!
  id: String
  key: String
}
type CustomerGroupSet implements MessagePayload {
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  type: String!
}
input CustomerGroupUpdateAction {
  changeName: ChangeCustomerGroupName
  setKey: SetCustomerGroupKey
  setCustomType: SetCustomerGroupCustomType
  setCustomField: SetCustomerGroupCustomField
}
type CustomerPasswordToken implements Versioned {
  customerId: String!
  expiresAt: DateTime!
  value: String!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type CustomerPasswordUpdated implements MessagePayload {
  reset: Boolean!
  type: String!
}
input CustomerSignInDraft {
  email: String!
  password: String!
  """This field will be deprecated in favour of anonymousCart.id."""
  anonymousCartId: String
  anonymousCart: ResourceIdentifierInput
  anonymousCartSignInMode: AnonymousCartSignInMode = MergeWithExistingCustomerCart
  anonymousId: String
  updateProductData: Boolean = false
}
type CustomerSignInResult {
  customer: Customer!
  cart: Cart
}
input CustomerSignMeInDraft {
  email: String!
  password: String!
  activeCartSignInMode: AnonymousCartSignInMode = MergeWithExistingCustomerCart
  updateProductData: Boolean = false
}
input CustomerSignMeUpDraft {
  email: String!
  password: String!
  firstName: String
  lastName: String
  middleName: String
  title: String
  dateOfBirth: Date
  companyName: String
  vatId: String
  addresses: [AddressInput!] = []
  """The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address."""
  defaultBillingAddress: Int
  """The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address."""
  defaultShippingAddress: Int
  """The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses."""
  shippingAddresses: [Int!] = []
  """The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses."""
  billingAddresses: [Int!] = []
  custom: CustomFieldsDraft
  locale: Locale
  salutation: String
  key: String
  stores: [ResourceIdentifierInput!]
}
input CustomerSignUpDraft {
  email: String!
  password: String!
  firstName: String
  lastName: String
  middleName: String
  title: String
  dateOfBirth: Date
  companyName: String
  vatId: String
  addresses: [AddressInput!] = []
  """The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address."""
  defaultBillingAddress: Int
  """The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address."""
  defaultShippingAddress: Int
  """The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses."""
  shippingAddresses: [Int!] = []
  """The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses."""
  billingAddresses: [Int!] = []
  custom: CustomFieldsDraft
  locale: Locale
  salutation: String
  key: String
  stores: [ResourceIdentifierInput!]
  customerNumber: String
  """This field will be deprecated in favour of anonymousCart.id."""
  anonymousCartId: String
  anonymousCart: ResourceIdentifierInput
  externalId: String
  customerGroup: ResourceIdentifierInput
  isEmailVerified: Boolean
  anonymousId: String
}
input CustomerUpdateAction {
  addAddress: AddCustomerAddress
  addBillingAddressId: AddCustomerBillingAddressId
  addShippingAddressId: AddCustomerShippingAddressId
  addStore: AddCustomerStore
  changeAddress: ChangeCustomerAddress
  changeEmail: ChangeCustomerEmail
  removeAddress: RemoveCustomerAddress
  removeBillingAddressId: RemoveCustomerBillingAddressId
  removeShippingAddressId: RemoveCustomerShippingAddressId
  removeStore: RemoveCustomerStore
  setCompanyName: SetCustomerCompanyName
  setAddressCustomField: SetCustomerAddressCustomField
  setAddressCustomType: SetCustomerAddressCustomType
  setCustomField: SetCustomerCustomField
  setCustomType: SetCustomerCustomType
  setCustomerGroup: SetCustomerGroup
  setKey: SetCustomerKey
  setLocale: SetCustomerLocale
  setCustomerNumber: SetCustomerNumber
  setDateOfBirth: SetCustomerDateOfBirth
  setDefaultBillingAddress: SetCustomerDefaultBillingAddress
  setDefaultShippingAddress: SetCustomerDefaultShippingAddress
  setExternalId: SetCustomerExternalId
  setFirstName: SetCustomerFirstName
  setLastName: SetCustomerLastName
  setMiddleName: SetCustomerMiddleName
  setSalutation: SetCustomerSalutation
  setStores: SetCustomerStores
  setTitle: SetCustomerTitle
  setVatId: SetCustomerVatId
}
type DateAttribute implements Attribute {
  value: Date!
  name: String!
}
type DateField implements CustomField {
  value: Date!
  name: String!
}
type DateTimeAttribute implements Attribute {
  value: DateTime!
  name: String!
}
type DateTimeField implements CustomField {
  value: DateTime!
  name: String!
}
type DateTimeType implements FieldType {
  name: String!
}
type DateType implements FieldType {
  name: String!
}
type DeliveryAdded implements MessagePayload {
  delivery: Delivery!
  type: String!
}
type DeliveryAddressSet implements MessagePayload {
  deliveryId: String!
  address: Address
  oldAddress: Address
  type: String!
}
input DeliveryItemDraftType {
  id: String!
  quantity: Long!
}
type DeliveryItemsUpdated implements MessagePayload {
  deliveryId: String!
  items: [DeliveryItem!]!
  oldItems: [DeliveryItem!]!
  type: String!
}
type DeliveryRemoved implements MessagePayload {
  delivery: Delivery!
  type: String!
}
input DestinationInput {
  SQS: SQSDestinationInput
  SNS: SNSDestinationInput
  AzureServiceBus: AzureServiceBusDestinationInput
  EventGrid: EventGridDestinationInput
  GoogleCloudPubSub: GoogleCloudPubSubDestinationInput
}
input DimensionsInput {
  width: Int!
  height: Int!
}
input DiscountCodeDraft {
  code: String!
  name: [LocalizedStringItemInputType!]
  description: [LocalizedStringItemInputType!]
  cartDiscounts: [ReferenceInput!]!
  isActive: Boolean = true
  maxApplications: Long
  maxApplicationsPerCustomer: Long
  cartPredicate: String
  custom: CustomFieldsDraft
  validFrom: DateTime
  validUntil: DateTime
  groups: [String!] = []
}
input DiscountCodeUpdateAction {
  changeCartDiscounts: ChangeDiscountCodeCartDiscounts
  changeGroups: ChangeDiscountCodeGroups
  changeIsActive: ChangeDiscountCodeIsActive
  setCartPredicate: SetDiscountCodeCartPredicate
  setCustomField: SetDiscountCodeCustomField
  setCustomType: SetDiscountCodeCustomType
  setDescription: SetDiscountCodeDescription
  setMaxApplications: SetDiscountCodeMaxApplications
  setMaxApplicationsPerCustomer: SetDiscountCodeMaxApplicationsPerCustomer
  setName: SetDiscountCodeName
  setValidFrom: SetDiscountCodeValidFrom
  setValidFromAndUntil: SetDiscountCodeValidFromAndUntil
  setValidUntil: SetDiscountCodeValidUntil
}
input DiscountedProductPriceValueInput {
  value: BaseMoneyInput!
  discount: ReferenceInput!
}
type EnumAttribute implements Attribute {
  key: String!
  label: String!
  name: String!
}
type EnumField implements CustomField {
  key: String!
  name: String!
}
type EnumType implements FieldType {
  values: [EnumValue!]!
  name: String!
}
input EnumTypeDraft {
  values: [PlainEnumValueDraft!]!
}
type EnumValue {
  key: String!
  label: String!
}
input EnumValueInput {
  key: String!
  label: String!
}
type EventGridDestination implements Destination {
  uri: String!
  accessKey: String!
  type: String!
}
input EventGridDestinationInput {
  uri: String!
  accessKey: String!
}
input ExtensionDestinationInput {
  HTTP: HttpDestinationInput
  AWSLambda: AWSLambdaDestinationInput
}
input ExtensionDraft {
  key: String
  destination: ExtensionDestinationInput!
  triggers: [TriggerInput!]!
  timeoutInMs: Int
}
input ExtensionUpdateAction {
  changeDestination: ChangeExtensionDestination
  changeTriggers: ChangeExtensionTriggers
  setKey: SetExtensionKey
  setTimeoutInMs: SetExtensionTimeoutInMs
}
type ExternalDiscountValue implements ProductDiscountValue {
  type: String!
}
input ExternalDiscountValueInput {
  dummy: String
}
type ExternalLineItemTotalPrice {
  price: BaseMoney!
  totalPrice: Money!
}
input ExternalLineItemTotalPriceDraft {
  price: BaseMoneyInput!
  totalPrice: MoneyInput!
}
input ExternalOAuthDraft {
  url: String!
  authorizationHeader: String!
}
input ExternalTaxAmountDraft {
  totalGross: MoneyInput!
  taxRate: ExternalTaxRateDraft!
}
type ExternalTaxAmountDraftOutput {
  totalGross: Money!
  taxRate: ExternalTaxRateDraftOutput!
}
input ExternalTaxRateDraft {
  name: String!
  amount: Float!
  country: Country!
  state: String
  subRates: [SubRateDraft!] = []
  includedInPrice: Boolean = false
}
type ExternalTaxRateDraftOutput {
  name: String!
  amount: Float
  country: Country!
  state: String
  subRates: [SubRate!]!
  includedInPrice: Boolean!
}
input FieldDefinitionInput {
  type: FieldTypeInput!
  name: String!
  label: [LocalizedStringItemInputType!]!
  required: Boolean!
  inputHint: TextInputHint!
}
input FieldTypeEnumTypeDraft {
  values: [EnumValueInput!]!
}
input FieldTypeInput {
  Set: FieldTypeSetTypeDraft
  String: SimpleFieldTypeDraft
  LocalizedString: SimpleFieldTypeDraft
  Number: SimpleFieldTypeDraft
  Money: SimpleFieldTypeDraft
  Date: SimpleFieldTypeDraft
  Time: SimpleFieldTypeDraft
  DateTime: SimpleFieldTypeDraft
  Boolean: SimpleFieldTypeDraft
  Enum: FieldTypeEnumTypeDraft
  LocalizedEnum: FieldTypeLocalizedEnumTypeDraft
  Reference: FieldTypeReferenceTypeDraft
}
input FieldTypeLocalizedEnumTypeDraft {
  values: [LocalizedEnumValueInput!]!
}
input FieldTypeReferenceTypeDraft {
  referenceTypeId: String!
}
input FieldTypeSetElementTypeDraft {
  String: SimpleFieldTypeDraft
  LocalizedString: SimpleFieldTypeDraft
  Number: SimpleFieldTypeDraft
  Money: SimpleFieldTypeDraft
  Date: SimpleFieldTypeDraft
  Time: SimpleFieldTypeDraft
  DateTime: SimpleFieldTypeDraft
  Boolean: SimpleFieldTypeDraft
  Enum: FieldTypeEnumTypeDraft
  LocalizedEnum: FieldTypeLocalizedEnumTypeDraft
  Reference: FieldTypeReferenceTypeDraft
}
input FieldTypeSetTypeDraft {
  elementType: FieldTypeSetElementTypeDraft!
}
type FixedPriceDiscountValue implements CartDiscountValue {
  money: [Money!]!
  type: String!
}
input FixedPriceDiscountValueInput {
  money: [MoneyInput!]!
}
input GeometryInput {
  type: String!
  coordinates: [Float!]
}
type GiftLineItemValue implements CartDiscountValue {
  type: String!
  variantId: Int!
  productRef: ProductReferenceIdentifier!
  distributionChannelRef: ChannelReferenceIdentifier
  supplyChannelRef: ChannelReferenceIdentifier
}
input GiftLineItemValueInput {
  product: ResourceIdentifierInput!
  variantId: Int!
  distributionChannel: ResourceIdentifierInput
  supplyChannel: ResourceIdentifierInput
}
type GoogleCloudPubSubDestination implements Destination {
  projectId: String!
  topic: String!
  type: String!
}
input GoogleCloudPubSubDestinationInput {
  projectId: String!
  topic: String!
}
type HighPrecisionMoney implements BaseMoney {
  type: String!
  currencyCode: Currency!
  preciseAmount: Long!
  centAmount: Long!
  fractionDigits: Int!
}
input HighPrecisionMoneyInput {
  currencyCode: Currency!
  preciseAmount: Long!
  fractionDigits: Int!
  centAmount: Long
}
type HttpDestination implements ExtensionDestination {
  type: String!
  url: String!
  authentication: HttpDestinationAuthentication
}
interface HttpDestinationAuthentication {
  type: String!
}
input HttpDestinationAuthenticationInput {
  AuthorizationHeader: AuthorizationHeaderInput
  AzureFunctions: AzureFunctionsAuthenticationInput
}
input HttpDestinationInput {
  url: String!
  authentication: HttpDestinationAuthenticationInput
}
input ImageInput {
  url: String!
  label: String
  dimensions: DimensionsInput!
}
input ImportOrderCustomLineItemState {
  customLineItemId: String!
  state: [ItemStateDraftType!]!
}
input ImportOrderLineItemState {
  lineItemId: String!
  state: [ItemStateDraftType!]!
}
input ImportStagedOrderCustomLineItemState {
  customLineItemId: String!
  state: [ItemStateDraftType!]!
}
type ImportStagedOrderCustomLineItemStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
  state: Set!
}
input ImportStagedOrderLineItemState {
  lineItemId: String!
  state: [ItemStateDraftType!]!
}
type ImportStagedOrderLineItemStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  state: Set!
}
type InventoryEntryCreated implements MessagePayload {
  inventoryEntry: InventoryEntryCreatedContent!
  type: String!
}
type InventoryEntryCreatedContent {
  inventoryEntryId: String!
  sku: String!
  quantityOnStock: Long!
  key: String
  restockableInDays: Int
  expectedDelivery: DateTime
  messageId: MessageId
  supplyChannel: Channel
  supplyChannelRef: Reference
  custom: CustomFieldsType
}
type InventoryEntryDeleted implements MessagePayload {
  sku: String!
  supplyChannel: Channel
  supplyChannelRef: Reference
  type: String!
}
input InventoryEntryDraft {
  sku: String!
  key: String
  quantityOnStock: Long
  restockableInDays: Int
  expectedDelivery: DateTime
  supplyChannel: ResourceIdentifierInput
  custom: CustomFieldsDraft
}
type InventoryEntryQuantitySet implements MessagePayload {
  oldQuantityOnStock: Long!
  newQuantityOnStock: Long!
  oldAvailableQuantity: Long!
  newAvailableQuantity: Long!
  type: String!
}
input InventoryEntryUpdateAction {
  addQuantity: AddInventoryEntryQuantity
  changeQuantity: ChangeInventoryEntryQuantity
  removeQuantity: RemoveInventoryEntryQuantity
  setRestockableInDays: SetInventoryEntryRestockableInDays
  setExpectedDelivery: SetInventoryEntryExpectedDelivery
  setSupplyChannel: SetInventoryEntrySupplyChannel
  setCustomType: SetInventoryEntryCustomType
  setCustomField: SetInventoryEntryCustomField
}
input ItemShippingDetailsDraft {
  targets: [ShippingTargetDraft!]!
}
type ItemShippingDetailsDraftOutput {
  targets: [ItemShippingTarget!]!
}
input ItemShippingDetailsDraftType {
  targets: [ShippingTargetDraftType!]!
}
input ItemStateDraftType {
  quantity: Long!
  state: ReferenceInput!
}
input LineItemDraft {
  productId: String
  sku: String
  quantity: Long
  variantId: Int
  supplyChannel: ResourceIdentifierInput
  distributionChannel: ResourceIdentifierInput
  custom: CustomFieldsDraft
  shippingDetails: ItemShippingDetailsDraft
  addedAt: DateTime
  externalTaxRate: ExternalTaxRateDraft
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
}
type LineItemDraftOutput {
  productId: String
  sku: String
  quantity: Long
  variantId: Int
  custom: CustomFieldsCommand
  externalTaxRate: ExternalTaxRateDraftOutput
  externalPrice: BaseMoney
  externalTotalPrice: ExternalLineItemTotalPrice
  shippingDetails: ItemShippingDetailsDraftOutput
  addedAt: DateTime
  distributionChannelResId: ResourceIdentifier
  supplyChannelResId: ResourceIdentifier
}
type LineItemReturnItem implements ReturnItem {
  type: String!
  lineItemId: String!
  id: String!
  quantity: Long!
  comment: String
  shipmentState: ReturnShipmentState!
  paymentState: ReturnPaymentState!
  lastModifiedAt: DateTime!
  createdAt: DateTime!
}
type LineItemStateTransition implements MessagePayload {
  lineItemId: String!
  transitionDate: DateTime!
  quantity: Long!
  fromState: State
  toState: State
  fromStateRef: Reference!
  toStateRef: Reference!
  type: String!
}
type LineItemsTarget implements CartDiscountTarget {
  predicate: String!
  type: String!
}
input LineItemsTargetInput {
  predicate: String!
}
input LocalizableEnumTypeDraft {
  values: [LocalizedEnumValueDraft!]!
}
type LocalizedEnumAttribute implements Attribute {
  key: String!
  label("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale!): String
  name: String!
}
type LocalizedEnumField implements CustomField {
  key: String!
  label("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale!): String
  name: String!
}
type LocalizedEnumType implements FieldType {
  values: [LocalizedEnumValue!]!
  name: String!
}
type LocalizedEnumValue {
  key: String!
  label("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  labelAllLocales: [LocalizedString!]!
}
input LocalizedEnumValueDraft {
  key: String!
  label: [LocalizedStringItemInputType!]!
}
input LocalizedEnumValueInput {
  key: String!
  label: [LocalizedStringItemInputType!]!
}
type LocalizedStringAttribute implements Attribute {
  value("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale!): String
  name: String!
}
type LocalizedStringField implements CustomField {
  value("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale!): String
  name: String!
}
input LocalizedStringItemInputType {
  locale: Locale!
  value: String!
}
type LocalizedStringType implements FieldType {
  name: String!
}
type MessageId {
  id: String!
  sequenceNumber: Long!
}
input MessageSubscriptionInput {
  resourceTypeId: String!
  types: [String!]
}
input MessagesConfigurationDraft {
  enabled: Boolean!
  deleteDaysAfterCreation: Int!
}
type MoneyAttribute implements Attribute {
  centAmount: Long!
  currencyCode: Currency!
  name: String!
}
input MoneyDraft {
  currencyCode: Currency!
  centAmount: Long!
}
type MoneyField implements CustomField {
  centAmount: Long!
  currencyCode: Currency!
  name: String!
}
input MoneyInput {
  currencyCode: Currency!
  centAmount: Long!
}
type MoneyType implements FieldType {
  name: String!
}
input MoveProductImageToPosition {
  variantId: Int
  sku: String
  imageUrl: String!
  position: Int!
  staged: Boolean
}
type MultiBuyCustomLineItemsTarget implements CartDiscountTarget {
  predicate: String!
  triggerQuantity: Long!
  discountedQuantity: Long!
  maxOccurrence: Int
  selectionMode: SelectionMode!
  type: String!
}
input MultiBuyCustomLineItemsTargetInput {
  predicate: String!
  triggerQuantity: Long!
  discountedQuantity: Long!
  maxOccurrence: Int
  selectionMode: SelectionMode
}
type MultiBuyLineItemsTarget implements CartDiscountTarget {
  predicate: String!
  triggerQuantity: Long!
  discountedQuantity: Long!
  maxOccurrence: Int
  selectionMode: SelectionMode!
  type: String!
}
input MultiBuyLineItemsTargetInput {
  predicate: String!
  triggerQuantity: Long!
  discountedQuantity: Long!
  maxOccurrence: Int
  selectionMode: SelectionMode
}
type Mutation {
  createCustomerGroup(draft: CustomerGroupDraft!): CustomerGroup
  updateCustomerGroup(version: Long!, actions: [CustomerGroupUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): CustomerGroup
  deleteCustomerGroup(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): CustomerGroup
  createCategory(draft: CategoryDraft!): Category
  updateCategory(version: Long!, actions: [CategoryUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Category
  deleteCategory(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Category
  createChannel(draft: ChannelDraft!): Channel
  updateChannel(id: String!, version: Long!, actions: [ChannelUpdateAction!]!): Channel
  deleteChannel(id: String!, version: Long!): Channel
  createOrUpdateCustomObject(draft: CustomObjectDraft!): CustomObject
  deleteCustomObject(version: Long, """Queries with specified ID""" id: String, """Queries with specified key""" key: String, container: String, personalDataErasure: Boolean = false): CustomObject
  createProductType(draft: ProductTypeDraft!): ProductTypeDefinition
  updateProductType(version: Long!, actions: [ProductTypeUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ProductTypeDefinition
  deleteProductType(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ProductTypeDefinition
  createTypeDefinition(draft: TypeDefinitionDraft!): TypeDefinition
  updateTypeDefinition(version: Long!, actions: [TypeUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): TypeDefinition
  deleteTypeDefinition(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): TypeDefinition
  createShippingMethod(draft: ShippingMethodDraft!): ShippingMethod
  updateShippingMethod(version: Long!, actions: [ShippingMethodUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShippingMethod
  deleteShippingMethod(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShippingMethod
  createZone(draft: CreateZone!): Zone
  updateZone(version: Long!, actions: [ZoneUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Zone
  deleteZone(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Zone
  createTaxCategory(draft: TaxCategoryDraft!): TaxCategory
  updateTaxCategory(version: Long!, actions: [TaxCategoryUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): TaxCategory
  deleteTaxCategory(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): TaxCategory
  createDiscountCode(draft: DiscountCodeDraft!): DiscountCode
  updateDiscountCode(id: String!, version: Long!, actions: [DiscountCodeUpdateAction!]!): DiscountCode
  deleteDiscountCode(id: String!, version: Long!): DiscountCode
  createCartDiscount(draft: CartDiscountDraft!): CartDiscount
  updateCartDiscount(version: Long!, actions: [CartDiscountUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): CartDiscount
  deleteCartDiscount(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): CartDiscount
  createProductDiscount(draft: ProductDiscountDraft!): ProductDiscount
  updateProductDiscount(version: Long!, actions: [ProductDiscountUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ProductDiscount
  deleteProductDiscount(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ProductDiscount
  createProduct(draft: ProductDraft!): Product
  updateProduct(version: Long!, actions: [ProductUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Product
  deleteProduct(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Product
  createState(draft: StateDraft!): State
  updateState(version: Long!, actions: [StateUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): State
  deleteState(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): State
  """Creates a customer. If an anonymous cart is given then the cart is assigned to the created customer and the version number of the Cart will increase. If the id of an anonymous session is given, all carts and orders will be assigned to the created customer."""
  customerSignUp(draft: CustomerSignUpDraft!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): CustomerSignInResult!
  """
  Retrieves the authenticated customer (a customer that matches the given email/password pair).

There may be carts and orders created before the sign in that should be assigned to the customer account. With the `anonymousCartId`, a single anonymous cart can be assigned. With the `anonymousId`, all orders and carts that have this `anonymousId` set will be assigned to the customer.
If both `anonymousCartId` and `anonymousId` are given, the anonymous cart must have the `anonymousId`.

Additionally, there might also exist one or more active customer carts from an earlier session. On customer sign in there are several ways how to proceed with this cart and the cart referenced by the `anonymousCartId`.

* If the customer does not have a cart yet, the anonymous cart becomes the customer's cart.
* If the customer already has one or more carts, the content of the anonymous cart will be copied to the customer's active cart that has been modified most recently.

  In this case the `CartState` of the anonymous cart gets changed to `Merged` while the customer's cart remains the `Active` cart.

  If a `LineItem` in the anonymous cart matches an existing line item, or a `CustomLineItem` matches an existing custom line item in the customer's cart, the maximum quantity of both line items is used as the new quantity.

  `ItemShippingDetails` are copied from the item with the highest quantity.

  If `itemShippingAddresses` are different in the two carts, the resulting cart contains the addresses of both the customer cart and the anonymous cart.

  Note, that it is not possible to merge carts that differ in their currency (set during creation of the cart).

If a cart is is returned as part of the `CustomerSignInResult`, it has been recalculated (it will have up-to-date prices, taxes and discounts, and invalid line items have been removed).
  """
  customerSignIn(draft: CustomerSignInDraft!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): CustomerSignInResult!
  updateCustomer(version: Long!, actions: [CustomerUpdateAction!]!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Customer
  deleteCustomer(version: Long!, personalDataErasure: Boolean = false, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Customer
  customerChangePassword(id: String!, version: Long!, currentPassword: String!, newPassword: String!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Customer
  """
  The following workflow can be used to reset the customer’s password:

1. Create a password reset token and send it embedded in a link to the customer.
2. When the customer clicks on the link, you may optionally retrieve customer by password token.
3. When the customer entered new password, use reset customer’s password to reset the password.
  """
  customerResetPassword(version: Long, tokenValue: String!, newPassword: String!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Customer
  """Verifies customer's email using a token."""
  customerConfirmEmail(version: Long, tokenValue: String!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Customer
  """The token value is used to reset the password of the customer with the given email. The token is valid only for 10 minutes."""
  customerCreatePasswordResetToken(email: String!, """The validity of the created token in minutes.""" ttlMinutes: Int, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): CustomerPasswordToken
  customerCreateEmailVerificationToken(id: String!, version: Long, """The validity of the created token in minutes.""" ttlMinutes: Int!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): CustomerEmailToken!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features If used with an access token for Anonymous Sessions, all orders and carts belonging to the anonymousId will be assigned to the newly created customer."""
  customerSignMeUp(draft: CustomerSignMeUpDraft!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): CustomerSignInResult!
  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features

Retrieves the authenticated customer (a customer that matches the given email/password pair).

If used with an access token for Anonymous Sessions, all orders and carts belonging to the `anonymousId` will be assigned to the newly created customer.

* If the customer does not have a cart yet, the anonymous cart that was modified most recently becomes the customer's cart.
* If the customer already has a cart, the most recently modified anonymous cart will be handled according to the `AnonymousCartSignInMode`.

If a cart is is returned as part of the `CustomerSignInResult`, it has been recalculated (it will have up-to-date prices, taxes and discounts, and invalid line items have been removed).
  """
  customerSignMeIn(draft: CustomerSignMeInDraft!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): CustomerSignInResult!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  updateMyCustomer(version: Long!, actions: [MyCustomerUpdateAction!]!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Customer
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  deleteMyCustomer(version: Long!, personalDataErasure: Boolean = false, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Customer
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  customerChangeMyPassword(version: Long!, currentPassword: String!, newPassword: String!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Customer
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  customerConfirmMyEmail(tokenValue: String!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Customer
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  customerResetMyPassword(tokenValue: String!, newPassword: String!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Customer
  createInventoryEntry(draft: InventoryEntryDraft!): InventoryEntry
  updateInventoryEntry(id: String!, version: Long!, actions: [InventoryEntryUpdateAction!]!): InventoryEntry
  deleteInventoryEntry(id: String!, version: Long!): InventoryEntry
  createCart(draft: CartDraft!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Cart
  updateCart(version: Long!, actions: [CartUpdateAction!]!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Cart
  deleteCart(version: Long!, personalDataErasure: Boolean = false, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Cart
  replicateCart(reference: ReferenceInput!, key: String, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Cart
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  createMyCart(draft: MyCartDraft!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Cart
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  updateMyCart(id: String!, version: Long!, actions: [MyCartUpdateAction!]!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Cart
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  deleteMyCart(id: String!, version: Long!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Cart
  createOrderFromCart(draft: OrderCartCommand!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Order
  updateOrder(version: Long!, actions: [OrderUpdateAction!]!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, orderNumber: String): Order
  deleteOrder(version: Long!, personalDataErasure: Boolean = false, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, orderNumber: String): Order
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  createMyOrderFromCart(draft: OrderMyCartCommand!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): Order
  createOrderEdit(draft: OrderEditDraft!): OrderEdit
  updateOrderEdit(version: Long!, actions: [OrderEditUpdateAction!]!, dryRun: Boolean = false, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): OrderEdit
  deleteOrderEdit(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): OrderEdit
  createShoppingList(draft: ShoppingListDraft!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): ShoppingList
  updateShoppingList(version: Long!, actions: [ShoppingListUpdateAction!]!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  deleteShoppingList(version: Long!, personalDataErasure: Boolean = false, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  createMyShoppingList(draft: MyShoppingListDraft!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput): ShoppingList
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  updateMyShoppingList(version: Long!, actions: [MyShoppingListUpdateAction!]!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  deleteMyShoppingList(version: Long!, """The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.""" storeKey: KeyReferenceInput, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  createPayment(draft: PaymentDraft!): Payment
  updatePayment(version: Long!, actions: [PaymentUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Payment
  deletePayment(version: Long!, personalDataErasure: Boolean = false, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Payment
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  createMyPayment(draft: MyPaymentDraft!): MyPayment
  updateMyPayment(id: String!, version: Long!, actions: [MyPaymentUpdateAction!]!): MyPayment
  deleteMyPayment(id: String!, version: Long!): MyPayment
  updateProject(version: Long!, actions: [ProjectSettingsUpdateAction!]!): ProjectProjection
  createStore(draft: CreateStore!): Store
  updateStore(version: Long!, actions: [StoreUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Store
  deleteStore(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Store
  createReview(draft: ReviewDraft!): Review
  updateReview(version: Long!, actions: [ReviewUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Review
  deleteReview(version: Long!, personalDataErasure: Boolean = false, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Review
  createSubscription(draft: SubscriptionDraft!): CommercetoolsSubscription
  updateSubscription(version: Long!, actions: [SubscriptionUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): CommercetoolsSubscription
  deleteSubscription(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): CommercetoolsSubscription
  createExtension(draft: ExtensionDraft!): Extension
  updateExtension(version: Long!, actions: [ExtensionUpdateAction!]!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Extension
  deleteExtension(version: Long!, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Extension
  createApiClient(draft: CreateApiClient!): APIClientWithSecret
  deleteApiClient(id: String!): APIClientWithoutSecret
}
input MyCartDraft {
  currency: Currency!
  country: Country
  inventoryMode: InventoryMode = None
  custom: CustomFieldsDraft
  customerEmail: String
  shippingAddress: AddressInput
  billingAddress: AddressInput
  shippingMethod: ResourceIdentifierInput
  taxMode: TaxMode = Platform
  locale: Locale
  deleteDaysAfterLastModification: Int
  itemShippingAddresses: [AddressInput!] = []
  discountCodes: [String!] = []
  store: ResourceIdentifierInput
  lineItems: [MyLineItemDraft!] = []
}
input MyCartUpdateAction {
  addDiscountCode: AddCartDiscountCode
  addItemShippingAddress: AddCartItemShippingAddress
  addLineItem: AddMyCartLineItem
  addPayment: AddCartPayment
  addShoppingList: AddCartShoppingList
  applyDeltaToLineItemShippingDetailsTargets: ApplyCartDeltaToLineItemShippingDetailsTargets
  changeLineItemQuantity: ChangeCartLineItemQuantity
  changeTaxMode: ChangeMyCartTaxMode
  recalculate: RecalculateCart
  removeDiscountCode: RemoveCartDiscountCode
  removeItemShippingAddress: RemoveCartItemShippingAddress
  removeLineItem: RemoveCartLineItem
  removePayment: RemoveCartPayment
  setBillingAddress: SetCartBillingAddress
  setBillingAddressCustomField: SetCartBillingAddressCustomField
  setBillingAddressCustomType: SetCartBillingAddressCustomType
  setCountry: SetCartCountry
  setCustomField: SetCartCustomField
  setCustomType: SetCartCustomType
  setCustomerEmail: SetCartCustomerEmail
  setDeleteDaysAfterLastModification: SetCartDeleteDaysAfterLastModification
  setItemShippingAddressCustomField: SetCartItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetCartItemShippingAddressCustomType
  setLineItemCustomField: SetCartLineItemCustomField
  setLineItemCustomType: SetCartLineItemCustomType
  setLineItemDistributionChannel: SetCartLineItemDistributionChannel
  setLineItemShippingDetails: SetCartLineItemShippingDetails
  setLocale: SetCartLocale
  setShippingMethod: SetMyCartShippingMethod
  setShippingAddress: SetCartShippingAddress
  setShippingAddressCustomField: SetCartShippingAddressCustomField
  setShippingAddressCustomType: SetCartShippingAddressCustomType
  updateItemShippingAddress: UpdateCartItemShippingAddress
}
input MyCustomerUpdateAction {
  addAddress: AddCustomerAddress
  addBillingAddressId: AddCustomerBillingAddressId
  addShippingAddressId: AddCustomerShippingAddressId
  changeAddress: ChangeCustomerAddress
  changeEmail: ChangeCustomerEmail
  removeAddress: RemoveCustomerAddress
  removeBillingAddressId: RemoveCustomerBillingAddressId
  removeShippingAddressId: RemoveCustomerShippingAddressId
  setCompanyName: SetCustomerCompanyName
  setAddressCustomField: SetCustomerAddressCustomField
  setAddressCustomType: SetCustomerAddressCustomType
  setCustomField: SetCustomerCustomField
  setCustomType: SetCustomerCustomType
  setLocale: SetCustomerLocale
  setDateOfBirth: SetCustomerDateOfBirth
  setDefaultBillingAddress: SetCustomerDefaultBillingAddress
  setDefaultShippingAddress: SetCustomerDefaultShippingAddress
  setFirstName: SetCustomerFirstName
  setLastName: SetCustomerLastName
  setMiddleName: SetCustomerMiddleName
  setSalutation: SetCustomerSalutation
  setTitle: SetCustomerTitle
  setVatId: SetCustomerVatId
}
input MyLineItemDraft {
  productId: String
  sku: String
  quantity: Long
  variantId: Int
  supplyChannel: ResourceIdentifierInput
  distributionChannel: ResourceIdentifierInput
  custom: CustomFieldsDraft
  shippingDetails: ItemShippingDetailsDraft
  addedAt: DateTime
}
input MyPaymentDraft {
  amountPlanned: MoneyInput!
  paymentMethodInfo: PaymentMethodInfoInput
  custom: CustomFieldsDraft
  transaction: MyTransactionDraft
}
input MyPaymentUpdateAction {
  addTransaction: AddMyPaymentTransaction
  changeAmountPlanned: ChangePaymentAmountPlanned
  setCustomField: SetPaymentCustomField
  setMethodInfoInterface: SetPaymentMethodInfoInterface
  setMethodInfoMethod: SetPaymentMethodInfoMethod
  setMethodInfoName: SetPaymentMethodInfoName
}
input MyShoppingListDraft {
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  lineItems: [ShoppingListLineItemDraft!] = []
  textLineItems: [TextLineItemDraft!] = []
  custom: CustomFieldsDraft
  deleteDaysAfterLastModification: Int
}
input MyShoppingListUpdateAction {
  addLineItem: AddShoppingListLineItem
  addTextLineItem: AddShoppingListTextLineItem
  changeLineItemQuantity: ChangeShoppingListLineItemQuantity
  changeLineItemsOrder: ChangeShoppingListLineItemsOrder
  changeName: ChangeShoppingListName
  changeTextLineItemName: ChangeShoppingListTextLineItemName
  changeTextLineItemQuantity: ChangeShoppingListTextLineItemQuantity
  changeTextLineItemsOrder: ChangeShoppingListTextLineItemsOrder
  removeLineItem: RemoveShoppingListLineItem
  removeTextLineItem: RemoveShoppingListTextLineItem
  setCustomField: SetShoppingListCustomField
  setCustomType: SetShoppingListCustomType
  setDeleteDaysAfterLastModification: SetShoppingListDeleteDaysAfterLastModification
  setDescription: SetShoppingListDescription
  setLineItemCustomField: SetShoppingListLineItemCustomField
  setLineItemCustomType: SetShoppingListLineItemCustomType
  setStore: SetShoppingListStore
  setTextLineItemCustomField: SetShoppingListTextLineItemCustomField
  setTextLineItemCustomType: SetShoppingListTextLineItemCustomType
  setTextLineItemDescription: SetShoppingListTextLineItemDescription
}
input MyTransactionDraft {
  timestamp: DateTime
  type: TransactionType!
  amount: MoneyInput!
  interactionId: String
}
type NotProcessed implements OrderEditResult {
  type: String!
}
type NumberAttribute implements Attribute {
  value: BigDecimal!
  name: String!
}
type NumberField implements CustomField {
  value: BigDecimal!
  name: String!
}
type NumberType implements FieldType {
  name: String!
}
type OrderBillingAddressSet implements MessagePayload {
  address: Address
  oldAddress: Address
  type: String!
}
input OrderCartCommand {
  id: String
  cart: ResourceIdentifierInput
  version: Long!
  paymentState: PaymentState
  orderState: OrderState
  state: ReferenceInput
  shipmentState: ShipmentState
  orderNumber: String
}
type OrderCreated implements MessagePayload {
  order: Order!
  type: String!
}
type OrderCustomLineItemAdded implements MessagePayload {
  customLineItem: CustomLineItem!
  type: String!
}
type OrderCustomLineItemDiscountSet implements MessagePayload {
  customLineItemId: String!
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  taxedPrice: TaxedItemPrice
  type: String!
}
type OrderCustomLineItemQuantityChanged implements MessagePayload {
  customLineItemId: String!
  quantity: Long!
  oldQuantity: Long
  type: String!
}
type OrderCustomLineItemRemoved implements MessagePayload {
  customLineItemId: String!
  customLineItem: CustomLineItem
  type: String!
}
type OrderCustomerEmailSet implements MessagePayload {
  email: String
  oldEmail: String
  type: String!
}
type OrderCustomerGroupSet implements MessagePayload {
  customerGroup: CustomerGroup
  oldCustomerGroup: CustomerGroup
  customerGroupRef: Reference
  oldCustomerGroupRef: Reference
  type: String!
}
type OrderCustomerSet implements MessagePayload {
  customer: Customer
  oldCustomer: Customer
  customerGroup: CustomerGroup
  oldCustomerGroup: CustomerGroup
  customerRef: Reference
  oldCustomerRef: Reference
  customerGroupRef: Reference
  oldCustomerGroupRef: Reference
  type: String!
}
type OrderDeleted implements MessagePayload {
  order: Order
  type: String!
}
type OrderDiscountCodeAdded implements MessagePayload {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}
type OrderDiscountCodeRemoved implements MessagePayload {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}
type OrderDiscountCodeStateSet implements MessagePayload {
  state: DiscountCodeState!
  oldState: DiscountCodeState
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}
type OrderEditApplied implements MessagePayload {
  result: Applied!
  edit: OrderEdit
  editRef: Reference!
  type: String!
}
input OrderEditDraft {
  key: String
  resource: ReferenceInput!
  stagedActions: [StagedOrderUpdateAction!]!
  custom: CustomFieldsDraft
  comment: String
  dryRun: Boolean
}
input OrderEditUpdateAction {
  addStagedAction: AddOrderEditStagedAction
  setComment: SetOrderEditComment
  setCustomField: SetOrderEditCustomField
  setCustomType: SetOrderEditCustomType
  setKey: SetOrderEditKey
  setStagedActions: SetOrderEditStagedActions
}
type OrderExcerpt {
  totalPrice: Money!
  taxedPrice: TaxedPrice
  version: Long
}
type OrderImported implements MessagePayload {
  order: Order!
  type: String!
}
type OrderLineItemAdded implements MessagePayload {
  lineItem: LineItem!
  addedQuantity: Long!
  type: String!
}
type OrderLineItemDiscountSet implements MessagePayload {
  lineItemId: String!
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  totalPrice: Money!
  taxedPrice: TaxedItemPrice
  type: String!
}
type OrderLineItemDistributionChannelSet implements MessagePayload {
  lineItemId: String!
  distributionChannel: Channel
  distributionChannelRef: Reference
  type: String!
}
type OrderLineItemRemoved implements MessagePayload {
  lineItemId: String!
  removedQuantity: Long!
  newQuantity: Long!
  newState: Set!
  newTotalPrice: Money!
  newTaxedPrice: TaxedItemPrice
  newPrice: ProductPrice
  newShippingDetails: ItemShippingDetails
  type: String!
}
input OrderMyCartCommand {
  id: String!
  version: Long!
}
type OrderPaymentAdded implements MessagePayload {
  paymentRef: Reference!
  type: String!
}
type OrderPaymentRemoved implements MessagePayload {
  paymentRef: Reference!
  removedPaymentInfo: Boolean!
  type: String!
}
type OrderPaymentStateChanged implements MessagePayload {
  paymentState: PaymentState!
  oldPaymentState: PaymentState
  type: String!
}
type OrderReturnShipmentStateChanged implements MessagePayload {
  returnItemId: String!
  returnShipmentState: ReturnShipmentState!
  type: String!
}
type OrderShipmentStateChanged implements MessagePayload {
  shipmentState: ShipmentState!
  oldShipmentState: ShipmentState
  type: String!
}
type OrderShippingAddressSet implements MessagePayload {
  address: Address
  oldAddress: Address
  type: String!
}
type OrderShippingInfoSet implements MessagePayload {
  shippingInfo: ShippingInfo
  oldShippingInfo: ShippingInfo
  type: String!
}
type OrderShippingRateInputSet implements MessagePayload {
  shippingRateInput: ShippingRateInput
  oldShippingRateInput: ShippingRateInput
  type: String!
}
type OrderStateChanged implements MessagePayload {
  orderId: String!
  orderState: OrderState!
  oldOrderState: OrderState
  type: String!
}
type OrderStateTransition implements MessagePayload {
  force: Boolean!
  state: State
  oldState: State
  stateRef: Reference!
  oldStateRef: Reference
  type: String!
}
type OrderStoreSet implements MessagePayload {
  store: Store
  oldStore: Store
  storeRef: KeyReference
  oldStoreRef: KeyReference
  type: String!
}
input OrderUpdateAction {
  addDelivery: AddOrderDelivery
  addItemShippingAddress: AddOrderItemShippingAddress
  addParcelToDelivery: AddOrderParcelToDelivery
  addPayment: AddOrderPayment
  addReturnInfo: AddOrderReturnInfo
  changeOrderState: ChangeOrderState
  changePaymentState: ChangeOrderPaymentState
  changeShipmentState: ChangeOrderShipmentState
  importCustomLineItemState: ImportOrderCustomLineItemState
  importLineItemState: ImportOrderLineItemState
  removeDelivery: RemoveOrderDelivery
  removeItemShippingAddress: RemoveOrderItemShippingAddress
  removeParcelFromDelivery: RemoveOrderParcelFromDelivery
  removePayment: RemoveOrderPayment
  setBillingAddress: SetOrderBillingAddress
  setBillingAddressCustomField: SetOrderBillingAddressCustomField
  setBillingAddressCustomType: SetOrderBillingAddressCustomType
  setCustomField: SetOrderCustomField
  setCustomLineItemCustomField: SetOrderCustomLineItemCustomField
  setCustomLineItemCustomType: SetOrderCustomLineItemCustomType
  setCustomLineItemShippingDetails: SetOrderCustomLineItemShippingDetails
  setCustomType: SetOrderCustomType
  setCustomerEmail: SetOrderCustomerEmail
  setCustomerId: SetOrderCustomerId
  setDeliveryAddress: SetOrderDeliveryAddress
  setDeliveryAddressCustomField: SetOrderDeliveryAddressCustomField
  setDeliveryAddressCustomType: SetOrderDeliveryAddressCustomType
  setDeliveryItems: SetOrderDeliveryItems
  setItemShippingAddressCustomField: SetOrderItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetOrderItemShippingAddressCustomType
  setLineItemCustomField: SetOrderLineItemCustomField
  setLineItemCustomType: SetOrderLineItemCustomType
  setLineItemShippingDetails: SetOrderLineItemShippingDetails
  setLocale: SetOrderLocale
  setOrderNumber: SetOrderNumber
  setParcelItems: SetOrderParcelItems
  setParcelMeasurements: SetOrderParcelMeasurements
  setParcelTrackingData: SetOrderParcelTrackingData
  setReturnPaymentState: SetOrderReturnPaymentState
  setReturnShipmentState: SetOrderReturnShipmentState
  setShippingAddress: SetOrderShippingAddress
  setShippingAddressCustomField: SetOrderShippingAddressCustomField
  setShippingAddressCustomType: SetOrderShippingAddressCustomType
  setStore: SetOrderStore
  transitionCustomLineItemState: TransitionOrderCustomLineItemState
  transitionLineItemState: TransitionOrderLineItemState
  transitionState: TransitionOrderState
  updateItemShippingAddress: UpdateOrderItemShippingAddress
  updateSyncInfo: UpdateOrderSyncInfo
}
type ParcelAddedToDelivery implements MessagePayload {
  delivery: Delivery!
  parcel: Parcel!
  type: String!
}
type ParcelData {
  measurements: ParcelMeasurements
  trackingData: TrackingData
  items: [DeliveryItem!]!
}
input ParcelDataDraftType {
  measurements: ParcelMeasurementsDraftType
  trackingData: TrackingDataDraftType
  items: [DeliveryItemDraftType!] = []
}
type ParcelItemsUpdated implements MessagePayload {
  deliveryId: String!
  parcelId: String!
  items: [DeliveryItem!]!
  oldItems: [DeliveryItem!]!
  type: String!
}
input ParcelMeasurementsDraftType {
  heightInMillimeter: Int
  lengthInMillimeter: Int
  widthInMillimeter: Int
  weightInGram: Int
}
type ParcelMeasurementsUpdated implements MessagePayload {
  deliveryId: String!
  parcelId: String!
  measurements: ParcelMeasurements
  type: String!
}
type ParcelRemovedFromDelivery implements MessagePayload {
  deliveryId: String!
  parcel: Parcel!
  type: String!
}
type ParcelTrackingDataUpdated implements MessagePayload {
  deliveryId: String!
  parcelId: String!
  trackingData: TrackingData
  type: String!
}
type PaymentCreated implements MessagePayload {
  payment: Payment!
  type: String!
}
input PaymentDraft {
  amountPlanned: MoneyInput!
  paymentMethodInfo: PaymentMethodInfoInput
  custom: CustomFieldsDraft
  key: String
  customer: ResourceIdentifierInput
  anonymousId: String
  interfaceId: String
  paymentStatus: PaymentStatusInput
  transactions: [TransactionDraft!]
  interfaceInteractions: [CustomFieldsDraft!]
}
type PaymentInteractionAdded implements MessagePayload {
  interaction: CustomFieldsType!
  type: String!
}
input PaymentMethodInfoInput {
  paymentInterface: String
  method: String
  name: [LocalizedStringItemInputType!]
}
input PaymentStatusInput {
  interfaceCode: String
  interfaceText: String
  state: ReferenceInput
}
type PaymentStatusInterfaceCodeSet implements MessagePayload {
  paymentId: String!
  interfaceCode: String
  type: String!
}
type PaymentStatusStateTransition implements MessagePayload {
  force: Boolean!
  state: State
  stateRef: Reference
  type: String!
}
type PaymentTransactionAdded implements MessagePayload {
  transaction: Transaction!
  type: String!
}
type PaymentTransactionStateChanged implements MessagePayload {
  transactionId: String!
  state: TransactionState!
  type: String!
}
input PaymentUpdateAction {
  addInterfaceInteraction: AddPaymentInterfaceInteraction
  addTransaction: AddPaymentTransaction
  changeAmountPlanned: ChangePaymentAmountPlanned
  changeTransactionInteractionId: ChangePaymentTransactionInteractionId
  changeTransactionState: ChangePaymentTransactionState
  changeTransactionTimestamp: ChangePaymentTransactionTimestamp
  setAmountPaid: SetPaymentAmountPaid
  setAmountRefunded: SetPaymentAmountRefunded
  setAnonymousId: SetPaymentAnonymousId
  setAuthorization: SetPaymentAuthorization
  setCustomField: SetPaymentCustomField
  setCustomType: SetPaymentCustomType
  setCustomer: SetPaymentCustomer
  setExternalId: SetPaymentExternalId
  setInterfaceId: SetPaymentInterfaceId
  setKey: SetPaymentKey
  setMethodInfoInterface: SetPaymentMethodInfoInterface
  setMethodInfoMethod: SetPaymentMethodInfoMethod
  setMethodInfoName: SetPaymentMethodInfoName
  setStatusInterfaceCode: SetPaymentStatusInterfaceCode
  setStatusInterfaceText: SetPaymentStatusInterfaceText
  transitionState: TransitionPaymentState
}
input PlainEnumValueDraft {
  key: String!
  label: String!
}
type PlatformFormat implements NotificationFormat {
  type: String!
}
input PlatformFormatInput {
  dummy: String
}
type Point implements Geometry {
  type: String!
  coordinates: [Float!]!
}
type PreviewFailure implements OrderEditResult {
  type: String!
  errors: [Json!]!
}
type PreviewSuccess implements OrderEditResult {
  type: String!
  preview: Order!
}
type PriceFunction {
  function: String!
  currencyCode: Currency!
}
input PriceFunctionDraft {
  function: String!
  currencyCode: Currency!
}
type ProductAddedToCategory implements MessagePayload {
  category: ReferenceId!
  staged: Boolean!
  type: String!
}
input ProductAttributeInput {
  name: String!
  value: String!
}
type ProductCreated implements MessagePayload {
  productProjection: ProductProjectionMessagePayload!
  type: String!
}
type ProductDeleted implements MessagePayload {
  removedImageUrls: Set!
  currentProjection: ProductProjectionMessagePayload
  type: String!
}
input ProductDiscountDraft {
  value: ProductDiscountValueInput!
  predicate: String!
  sortOrder: String!
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  validFrom: DateTime
  validUntil: DateTime
  isActive: Boolean = true
  key: String
}
input ProductDiscountUpdateAction {
  changeIsActive: ChangeProductDiscountIsActive
  changeName: ChangeProductDiscountName
  changePredicate: ChangeProductDiscountPredicate
  changeSortOrder: ChangeProductDiscountSortOrder
  changeValue: ChangeProductDiscountValue
  setDescription: SetProductDiscountDescription
  setKey: SetProductDiscountKey
  setValidFrom: SetProductDiscountValidFrom
  setValidFromAndUntil: SetProductDiscountValidFromAndUntil
  setValidUntil: SetProductDiscountValidUntil
}
input ProductDiscountValueInput {
  relative: RelativeDiscountValueInput
  absolute: AbsoluteDiscountValueInput
  external: ExternalDiscountValueInput
}
input ProductDraft {
  name: [LocalizedStringItemInputType!]!
  productType: ResourceIdentifierInput!
  slug: [LocalizedStringItemInputType!]!
  key: String
  description: [LocalizedStringItemInputType!]
  categories: [ResourceIdentifierInput!]
  categoryOrderHints: [CategoryOrderHintInput!]
  metaTitle: [LocalizedStringItemInputType!]
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  masterVariant: ProductVariantInput
  variants: [ProductVariantInput!] = []
  taxCategory: ResourceIdentifierInput
  state: ResourceIdentifierInput
  searchKeywords: [SearchKeywordInput!]
  publish: Boolean
}
type ProductImageAdded implements MessagePayload {
  variantId: Int!
  image: Image!
  staged: Boolean!
  type: String!
}
input ProductPriceDataInput {
  value: BaseMoneyInput!
  country: Country
  customerGroup: ReferenceInput
  channel: ResourceIdentifierInput
  validFrom: DateTime
  validUntil: DateTime
  tiers: [ProductPriceTierInput!] = []
  custom: CustomFieldsDraft
}
type ProductPriceDiscountUpdateMessagePayload {
  variantId: Int!
  variantKey: String
  sku: String
  priceId: String!
  discounted: DiscountedProductPriceValue
  staged: Boolean!
}
type ProductPriceDiscountsSet implements MessagePayload {
  updatedPrices: [ProductPriceDiscountUpdateMessagePayload!]!
  type: String!
}
type ProductPriceExternalDiscountSet implements MessagePayload {
  variantId: Int!
  variantKey: String
  sku: String
  priceId: String!
  discounted: DiscountedProductPriceValue
  staged: Boolean!
  type: String!
}
input ProductPriceTierInput {
  minimumQuantity: Int!
  value: BaseMoneyInput!
}
type ProductProjectionMessagePayload {
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  productTypeRef: Reference!
  productType: ProductTypeDefinition
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  categoryOrderHints: [CategoryOrderHint!]!
  categoriesRef: [Reference!]!
  categories: [Category!]!
  searchKeywords: [SearchKeywords!]!
  metaTitle("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaKeywords("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaDescription("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  hasStagedChanges: Boolean!
  published: Boolean!
  masterVariant: ProductVariant!
  variants: [ProductVariant!]!
  taxCategoryRef: Reference
  taxCategory: TaxCategory
  stateRef: Reference
  state: State
  reviewRatingStatistics: ReviewRatingStatistics
}
type ProductPublished implements MessagePayload {
  productProjection: ProductProjectionMessagePayload!
  removedImageUrls: [String!]!
  scope: PublishScope!
  type: String!
}
type ProductReferenceIdentifier {
  typeId: String!
  id: String
  key: String
}
type ProductRemovedFromCategory implements MessagePayload {
  category: ReferenceId!
  staged: Boolean!
  type: String!
}
type ProductRevertedStagedChanges implements MessagePayload {
  removedImageUrls: Set!
  type: String!
}
type ProductSlugChanged implements MessagePayload {
  slug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  oldSlug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  oldSlugAllLocales: [LocalizedString!]
  type: String!
}
type ProductStateTransition implements MessagePayload {
  force: Boolean!
  state: State
  stateRef: Reference!
  type: String!
}
input ProductTypeDraft {
  name: String!
  description: String!
  key: String
  attributeDefinitions: [AttributeDefinitionDraft!]
}
input ProductTypeUpdateAction {
  setKey: setKey
  changeName: changeName
  changeDescription: changeDescription
  removeAttributeDefinition: removeAttributeDefinition
  changeLabel: changeLabel
  setInputTip: setInputTip
  changeIsSearchable: changeIsSearchable
  changeInputHint: changeInputHint
  addAttributeDefinition: addAttributeDefinition
  changeAttributeOrder: changeAttributeOrder
  changeAttributeOrderByName: changeAttributeOrderByName
  removeEnumValues: removeEnumValues
  addPlainEnumValue: addPlainEnumValue
  changePlainEnumValueLabel: changePlainEnumValueLabel
  changePlainEnumValueOrder: changePlainEnumValueOrder
  addLocalizedEnumValue: addLocalizedEnumValue
  changeLocalizedEnumValueLabel: changeLocalizedEnumValueLabel
  changeLocalizedEnumValueOrder: changeLocalizedEnumValueOrder
  changeAttributeName: changeAttributeName
  changeEnumKey: changeEnumKey
}
type ProductUnpublished implements MessagePayload {
  type: String!
}
input ProductUpdateAction {
  moveImageToPosition: MoveProductImageToPosition
  setSearchKeywords: SetSearchKeywords
  revertStagedChanges: RevertStagedChanges
  revertStagedVariantChanges: RevertStagedVariantChanges
  publish: PublishProduct
  unpublish: UnpublishProduct
  transitionState: TransitionProductState
  addAsset: AddProductAsset
  addExternalImage: AddProductExternalImage
  addPrice: AddProductPrice
  addToCategory: AddProductToCategory
  addVariant: AddProductVariant
  changeAssetName: ChangeProductAssetName
  changeAssetOrder: ChangeProductAssetOrder
  changeMasterVariant: ChangeProductMasterVariant
  changeImageLabel: ChangeProductImageLabel
  changeName: ChangeProductName
  changePrice: ChangeProductPrice
  changeSlug: ChangeProductSlug
  removeAsset: RemoveProductAsset
  removeFromCategory: RemoveProductFromCategory
  removeImage: RemoveProductImage
  removePrice: RemoveProductPrice
  removeVariant: RemoveProductVariant
  setAssetCustomField: SetProductAssetCustomField
  setAssetCustomType: SetProductAssetCustomType
  setAssetDescription: SetProductAssetDescription
  setAssetKey: SetProductAssetKey
  setAssetSources: SetProductAssetSources
  setAssetTags: SetProductAssetTags
  setCategoryOrderHint: SetProductCategoryOrderHint
  setDiscountedPrice: SetProductDiscountedPrice
  setAttribute: SetProductAttribute
  setAttributeInAllVariants: SetProductAttributeInAllVariants
  setDescription: SetProductDescription
  setImageLabel: SetProductImageLabel
  setKey: SetProductKey
  setMetaAttributes: SetProductMetaAttributes
  setMetaDescription: SetProductMetaDescription
  setMetaKeywords: SetProductMetaKeywords
  setMetaTitle: SetProductMetaTitle
  setProductPriceCustomField: SetProductPriceCustomField
  setProductPriceCustomType: SetProductPriceCustomType
  setPrices: SetProductPrices
  setSku: SetProductSku
  setTaxCategory: SetProductTaxCategory
  setProductVariantKey: SetProductVariantKey
}
type ProductVariantAdded implements MessagePayload {
  variant: ProductVariant!
  staged: Boolean!
  type: String!
}
type ProductVariantDeleted implements MessagePayload {
  removedImageUrls: Set!
  variant: ProductVariant
  type: String!
}
input ProductVariantInput {
  sku: String
  key: String
  prices: [ProductPriceDataInput!] = []
  images: [ImageInput!] = []
  attributes: [ProductAttributeInput!] = []
  assets: [AssetDraftInput!] = []
}
input ProjectSettingsUpdateAction {
  changeCartsConfiguration: ChangeProjectSettingsCartsConfiguration
  changeCountries: ChangeProjectSettingsCountries
  changeCountryTaxRateFallbackEnabled: ChangeProjectSettingsCountryTaxRateFallbackEnabled
  changeCurrencies: ChangeProjectSettingsCurrencies
  changeLanguages: ChangeProjectSettingsLanguages
  changeMessagesConfiguration: ChangeProjectSettingsMessagesConfiguration
  changeMessagesEnabled: ChangeProjectSettingsMessagesEnabled
  changeName: ChangeProjectSettingsName
  changeOrderSearchStatus: ChangeProjectSettingsOrderSearchStatus
  changeProductSearchIndexingEnabled: ChangeProjectSettingsProductSearchIndexingEnabled
  changeShoppingListsConfiguration: ChangeProjectSettingsShoppingListsConfiguration
  setExternalOAuth: SetProjectSettingsExternalOAuth
  setShippingRateInputType: SetProjectSettingsShippingRateInputType
}
input PublishProduct {
  scope: PublishScope
}
enum PublishScope {
  """Publishes the complete staged projection"""
  All
  """Publishes only prices on the staged projection"""
  Prices
}
interface RangeCount {
  type: String!
}
type RangeCountDouble implements RangeCount {
  from: Float!
  fromStr: String!
  to: Float!
  toStr: String!
  count: Int!
  productCount: Int
  totalCount: Int!
  total: Float!
  min: Float!
  max: Float!
  mean: Float!
  type: String!
}
type RangeCountLong implements RangeCount {
  from: Long!
  fromStr: String!
  to: Long!
  toStr: String!
  count: Int!
  productCount: Int
  totalCount: Int!
  total: Long!
  min: Long!
  max: Long!
  mean: Float!
  type: String!
}
type RangeFacetResult implements FacetResult {
  dataType: String!
  ranges: [RangeCount!]!
  type: String!
}
input RecalculateCart {
  updateProductData: Boolean = false
}
input RecalculateStagedOrder {
  updateProductData: Boolean = false
}
type RecalculateStagedOrderOutput implements StagedOrderUpdateActionOutput {
  type: String!
  updateProductData: Boolean!
}
type ReferenceAttribute implements Attribute {
  typeId: String!
  id: String!
  name: String!
}
type ReferenceField implements CustomField {
  typeId: String!
  id: String!
  name: String!
}
type ReferenceId {
  typeId: String!
  id: String!
}
type ReferenceType implements FieldType {
  referenceTypeId: String!
  name: String!
}
input ReferenceTypeDefinitionDraft {
  referenceTypeId: String!
}
type RelativeDiscountValue implements CartDiscountValue& ProductDiscountValue {
  permyriad: Int!
  type: String!
}
input RelativeDiscountValueInput {
  permyriad: Int!
}
input RemoveCartCustomLineItem {
  customLineItemId: String!
}
input RemoveCartDiscountCode {
  discountCode: ReferenceInput!
}
input RemoveCartItemShippingAddress {
  addressKey: String!
}
input RemoveCartLineItem {
  lineItemId: String!
  quantity: Long
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  shippingDetailsToRemove: ItemShippingDetailsDraft
}
input RemoveCartPayment {
  payment: ResourceIdentifierInput!
}
input RemoveCategoryAsset {
  assetKey: String
  assetId: String
}
input RemoveChannelRoles {
  roles: [ChannelRole!]!
}
input RemoveCustomerAddress {
  addressId: String
  addressKey: String
}
input RemoveCustomerBillingAddressId {
  addressId: String
  addressKey: String
}
input RemoveCustomerShippingAddressId {
  addressId: String
  addressKey: String
}
input RemoveCustomerStore {
  store: ResourceIdentifierInput!
}
input RemoveInventoryEntryQuantity {
  quantity: Long!
}
input RemoveOrderDelivery {
  deliveryId: String!
}
input RemoveOrderItemShippingAddress {
  addressKey: String!
}
input RemoveOrderParcelFromDelivery {
  parcelId: String!
}
input RemoveOrderPayment {
  payment: ResourceIdentifierInput!
}
input RemoveProductAsset {
  variantId: Int
  sku: String
  staged: Boolean = true
  assetKey: String
  assetId: String
}
input RemoveProductFromCategory {
  category: ResourceIdentifierInput!
  staged: Boolean = true
}
input RemoveProductImage {
  variantId: Int
  sku: String
  imageUrl: String!
  staged: Boolean = true
}
input RemoveProductPrice {
  priceId: String
  variantId: Int
  sku: String
  price: ProductPriceDataInput
  staged: Boolean = true
}
input RemoveProductVariant {
  id: Int
  sku: String
  staged: Boolean = true
}
input RemoveShippingMethodShippingRate {
  zone: ResourceIdentifierInput!
  shippingRate: ShippingRateDraft!
}
input RemoveShippingMethodZone {
  zone: ResourceIdentifierInput!
}
input RemoveShoppingListLineItem {
  lineItemId: String!
  quantity: Int
}
input RemoveShoppingListTextLineItem {
  textLineItemId: String!
  quantity: Int
}
input RemoveStagedOrderCustomLineItem {
  customLineItemId: String!
}
type RemoveStagedOrderCustomLineItemOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
}
input RemoveStagedOrderDelivery {
  deliveryId: String!
}
type RemoveStagedOrderDeliveryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String!
}
input RemoveStagedOrderDiscountCode {
  discountCode: ReferenceInput!
}
type RemoveStagedOrderDiscountCodeOutput implements StagedOrderUpdateActionOutput {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}
input RemoveStagedOrderItemShippingAddress {
  addressKey: String!
}
type RemoveStagedOrderItemShippingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  addressKey: String!
}
input RemoveStagedOrderLineItem {
  lineItemId: String!
  quantity: Long
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  shippingDetailsToRemove: ItemShippingDetailsDraftType
}
type RemoveStagedOrderLineItemOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  quantity: Long
  externalPrice: BaseMoney
  externalTotalPrice: ExternalLineItemTotalPrice
  shippingDetailsToRemove: ItemShippingDetailsDraftOutput
}
input RemoveStagedOrderParcelFromDelivery {
  parcelId: String!
}
type RemoveStagedOrderParcelFromDeliveryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  parcelId: String!
}
input RemoveStagedOrderPayment {
  payment: ResourceIdentifierInput!
}
type RemoveStagedOrderPaymentOutput implements StagedOrderUpdateActionOutput {
  type: String!
  paymentResId: ResourceIdentifier!
}
input RemoveStateRoles {
  roles: [StateRole!]!
}
input RemoveStoreDistributionChannel {
  distributionChannel: ResourceIdentifierInput!
}
input RemoveStoreSupplyChannel {
  supplyChannel: ResourceIdentifierInput!
}
input RemoveTypeFieldDefinition {
  fieldName: String!
}
input RemoveZoneLocation {
  location: ZoneLocation!
}
type ResourceIdentifier {
  typeId: String!
  key: String
  id: String
}
input ResourceIdentifierInput {
  typeId: String
  id: String
  key: String
}
type ReturnInfoAdded implements MessagePayload {
  returnInfo: ReturnInfo!
  type: String!
}
input ReturnItemDraftType {
  quantity: Long!
  lineItemId: String
  customLineItemId: String
  comment: String
  shipmentState: ReturnShipmentState!
}
type ReturnItemDraftTypeOutput {
  quantity: Long!
  lineItemId: String
  customLineItemId: String
  comment: String
  shipmentState: ReturnShipmentState!
}
input RevertStagedChanges {
  dummy: String
}
input RevertStagedVariantChanges {
  variantId: Int!
}
type ReviewCreated implements MessagePayload {
  review: Review!
  type: String!
}
input ReviewDraft {
  key: String
  uniquenessValue: String
  locale: Locale
  authorName: String
  title: String
  text: String
  target: TargetReferenceInput
  state: ResourceIdentifierInput
  rating: Int
  customer: ResourceIdentifierInput
  custom: CustomFieldsDraft
}
type ReviewRatingSet implements MessagePayload {
  oldRating: Int
  newRating: Int
  includedInStatistics: Boolean!
  target: ReviewTarget
  targetRef: Reference
  type: String!
}
type ReviewStateTransition implements MessagePayload {
  oldIncludedInStatistics: Boolean!
  newIncludedInStatistics: Boolean!
  force: Boolean!
  target: ReviewTarget
  oldState: State
  newState: State
  targetRef: Reference
  oldStateRef: Reference
  newStateRef: Reference!
  type: String!
}
input ReviewUpdateAction {
  setAuthorName: SetReviewAuthorName
  setCustomField: SetReviewCustomField
  setCustomType: SetReviewCustomType
  setCustomer: SetReviewCustomer
  setKey: SetReviewKey
  setLocale: SetReviewLocale
  setRating: SetReviewRating
  setTarget: SetReviewTarget
  setText: SetReviewText
  setTitle: SetReviewTitle
  transitionState: TransitionReviewState
}
type SNSDestination implements Destination {
  topicArn: String!
  accessKey: String!
  accessSecret: String!
  type: String!
}
input SNSDestinationInput {
  topicArn: String!
  accessKey: String!
  accessSecret: String!
}
type SQSDestination implements Destination {
  queueUrl: String!
  accessKey: String!
  accessSecret: String!
  region: String!
  type: String!
}
input SQSDestinationInput {
  queueUrl: String!
  accessKey: String!
  accessSecret: String!
  region: String!
}
type ScoreShippingRateInput implements ShippingRateInput {
  score: Int!
  type: String!
}
input ScoreShippingRateInputDraft {
  score: Int!
}
type ScoreShippingRateInputDraftOutput implements ShippingRateInputDraftOutput {
  score: Int!
  type: String!
}
input SearchKeywordInput {
  locale: Locale!
  keywords: [SearchKeywordItemInput!]!
}
input SearchKeywordItemInput {
  text: String!
  suggestTokenizer: BaseSearchKeywordInput
}
enum SelectionMode {
  MostExpensive
  Cheapest
}
"""A set."""
scalar Set
input SetCartAnonymousId {
  anonymousId: String
}
input SetCartBillingAddress {
  address: AddressInput
}
input SetCartBillingAddressCustomField {
  name: String!
  value: String
}
input SetCartBillingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetCartCountry {
  country: Country
}
input SetCartCustomField {
  name: String!
  value: String
}
input SetCartCustomLineItemCustomField {
  customLineItemId: String!
  name: String!
  value: String
}
input SetCartCustomLineItemCustomType {
  customLineItemId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetCartCustomLineItemShippingDetails {
  customLineItemId: String!
  shippingDetails: ItemShippingDetailsDraft
}
input SetCartCustomLineItemTaxAmount {
  customLineItemId: String!
  externalTaxAmount: ExternalTaxAmountDraft
}
input SetCartCustomLineItemTaxRate {
  customLineItemId: String!
  externalTaxRate: ExternalTaxRateDraft
}
input SetCartCustomShippingMethod {
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}
input SetCartCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetCartCustomerEmail {
  email: String
}
input SetCartCustomerGroup {
  customerGroup: ResourceIdentifierInput
}
input SetCartCustomerId {
  customerId: String
}
input SetCartDeleteDaysAfterLastModification {
  deleteDaysAfterLastModification: Int
}
input SetCartDiscountCustomField {
  name: String!
  value: String
}
input SetCartDiscountCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetCartDiscountDescription {
  description: [LocalizedStringItemInputType!]
}
input SetCartDiscountKey {
  key: String
}
input SetCartDiscountValidFrom {
  validFrom: DateTime
}
input SetCartDiscountValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}
input SetCartDiscountValidUntil {
  validUntil: DateTime
}
input SetCartItemShippingAddressCustomField {
  addressKey: String!
  name: String!
  value: String
}
input SetCartItemShippingAddressCustomType {
  addressKey: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetCartKey {
  key: String
}
input SetCartLineItemCustomField {
  lineItemId: String!
  name: String!
  value: String
}
input SetCartLineItemCustomType {
  lineItemId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetCartLineItemDistributionChannel {
  lineItemId: String!
  distributionChannel: ResourceIdentifierInput
}
input SetCartLineItemPrice {
  lineItemId: String!
  externalPrice: BaseMoneyInput
}
input SetCartLineItemShippingDetails {
  lineItemId: String!
  shippingDetails: ItemShippingDetailsDraft
}
input SetCartLineItemTaxAmount {
  lineItemId: String!
  externalTaxAmount: ExternalTaxAmountDraft
}
input SetCartLineItemTaxRate {
  lineItemId: String!
  externalTaxRate: ExternalTaxRateDraft
}
input SetCartLineItemTotalPrice {
  lineItemId: String!
  externalTotalPrice: ExternalLineItemTotalPriceDraft
}
input SetCartLocale {
  locale: Locale
}
input SetCartShippingAddress {
  address: AddressInput
}
input SetCartShippingAddressCustomField {
  name: String!
  value: String
}
input SetCartShippingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetCartShippingMethod {
  shippingMethod: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}
input SetCartShippingMethodTaxAmount {
  externalTaxAmount: ExternalTaxAmountDraft
}
input SetCartShippingMethodTaxRate {
  externalTaxRate: ExternalTaxRateDraft
}
input SetCartShippingRateInput {
  shippingRateInput: ShippingRateInputDraft
}
input SetCartTotalTax {
  externalTotalGross: MoneyInput
  externalTaxPortions: [TaxPortionDraft!] = []
}
input SetCategoryAssetCustomField {
  value: String
  name: String!
  assetKey: String
  assetId: String
}
input SetCategoryAssetCustomType {
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
  assetKey: String
  assetId: String
}
input SetCategoryAssetDescription {
  description: [LocalizedStringItemInputType!]
  assetKey: String
  assetId: String
}
input SetCategoryAssetKey {
  assetKey: String
  assetId: String!
}
input SetCategoryAssetSources {
  sources: [AssetSourceInput!] = []
  assetKey: String
  assetId: String
}
input SetCategoryAssetTags {
  tags: [String!] = []
  assetKey: String
  assetId: String
}
input SetCategoryCustomField {
  name: String!
  value: String
}
input SetCategoryCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetCategoryDescription {
  description: [LocalizedStringItemInputType!]
}
input SetCategoryExternalId {
  externalId: String
}
input SetCategoryKey {
  key: String
}
input SetCategoryMetaDescription {
  metaDescription: [LocalizedStringItemInputType!]
}
input SetCategoryMetaKeywords {
  metaKeywords: [LocalizedStringItemInputType!]
}
input SetCategoryMetaTitle {
  metaTitle: [LocalizedStringItemInputType!]
}
input SetChannelAddress {
  address: AddressInput
}
input SetChannelAddressCustomField {
  name: String!
  value: String
}
input SetChannelAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetChannelCustomField {
  name: String!
  value: String
}
input SetChannelCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetChannelGeoLocation {
  geoLocation: GeometryInput
}
input SetChannelRoles {
  roles: [ChannelRole!]!
}
input SetCustomerAddressCustomField {
  name: String!
  value: String
  addressId: String!
}
input SetCustomerAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
  addressId: String!
}
input SetCustomerCompanyName {
  companyName: String
}
input SetCustomerCustomField {
  name: String!
  value: String
}
input SetCustomerCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetCustomerDateOfBirth {
  dateOfBirth: Date
}
input SetCustomerDefaultBillingAddress {
  addressId: String
  addressKey: String
}
input SetCustomerDefaultShippingAddress {
  addressId: String
  addressKey: String
}
input SetCustomerExternalId {
  externalId: String
}
input SetCustomerFirstName {
  firstName: String
}
input SetCustomerGroup {
  customerGroup: ResourceIdentifierInput
}
input SetCustomerGroupCustomField {
  name: String!
  value: String
}
input SetCustomerGroupCustomType {
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
}
input SetCustomerGroupKey {
  key: String
}
input SetCustomerKey {
  key: String
}
input SetCustomerLastName {
  lastName: String
}
input SetCustomerLocale {
  locale: Locale
}
input SetCustomerMiddleName {
  middleName: String
}
input SetCustomerNumber {
  customerNumber: String
}
input SetCustomerSalutation {
  salutation: String
}
input SetCustomerStores {
  stores: [ResourceIdentifierInput!]!
}
input SetCustomerTitle {
  title: String
}
input SetCustomerVatId {
  vatId: String
}
input SetDiscountCodeCartPredicate {
  cartPredicate: String
}
input SetDiscountCodeCustomField {
  name: String!
  value: String
}
input SetDiscountCodeCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetDiscountCodeDescription {
  description: [LocalizedStringItemInputType!]
}
input SetDiscountCodeMaxApplications {
  maxApplications: Long
}
input SetDiscountCodeMaxApplicationsPerCustomer {
  maxApplicationsPerCustomer: Long
}
input SetDiscountCodeName {
  name: [LocalizedStringItemInputType!]
}
input SetDiscountCodeValidFrom {
  validFrom: DateTime
}
input SetDiscountCodeValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}
input SetDiscountCodeValidUntil {
  validUntil: DateTime
}
input SetExtensionKey {
  key: String
}
input SetExtensionTimeoutInMs {
  timeoutInMs: Int
}
input SetInventoryEntryCustomField {
  name: String!
  value: String
}
input SetInventoryEntryCustomType {
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
}
input SetInventoryEntryExpectedDelivery {
  expectedDelivery: DateTime
}
input SetInventoryEntryRestockableInDays {
  restockableInDays: Int
}
input SetInventoryEntrySupplyChannel {
  supplyChannel: ResourceIdentifierInput
}
input SetMyCartShippingMethod {
  shippingMethod: ResourceIdentifierInput
}
input SetOrderBillingAddress {
  address: AddressInput
}
input SetOrderBillingAddressCustomField {
  name: String!
  value: String
}
input SetOrderBillingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetOrderCustomField {
  name: String!
  value: String
}
input SetOrderCustomLineItemCustomField {
  customLineItemId: String!
  name: String!
  value: String
}
input SetOrderCustomLineItemCustomType {
  customLineItemId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetOrderCustomLineItemShippingDetails {
  customLineItemId: String!
  shippingDetails: ItemShippingDetailsDraftType
}
input SetOrderCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetOrderCustomerEmail {
  email: String
}
input SetOrderCustomerId {
  customerId: String
}
input SetOrderDeliveryAddress {
  deliveryId: String!
  address: AddressInput
}
input SetOrderDeliveryAddressCustomField {
  deliveryId: String!
  name: String!
  value: String
}
input SetOrderDeliveryAddressCustomType {
  deliveryId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetOrderDeliveryItems {
  deliveryId: String!
  items: [DeliveryItemDraftType!]!
}
input SetOrderEditComment {
  comment: String
}
input SetOrderEditCustomField {
  name: String!
  value: String
}
input SetOrderEditCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetOrderEditKey {
  key: String
}
input SetOrderEditStagedActions {
  stagedActions: [StagedOrderUpdateAction!]!
}
input SetOrderItemShippingAddressCustomField {
  addressKey: String!
  name: String!
  value: String
}
input SetOrderItemShippingAddressCustomType {
  addressKey: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetOrderLineItemCustomField {
  lineItemId: String!
  name: String!
  value: String
}
input SetOrderLineItemCustomType {
  lineItemId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetOrderLineItemShippingDetails {
  lineItemId: String!
  shippingDetails: ItemShippingDetailsDraftType
}
input SetOrderLocale {
  locale: Locale
}
input SetOrderNumber {
  orderNumber: String
}
input SetOrderParcelItems {
  parcelId: String!
  items: [DeliveryItemDraftType!]!
}
input SetOrderParcelMeasurements {
  parcelId: String!
  measurements: ParcelMeasurementsDraftType
}
input SetOrderParcelTrackingData {
  parcelId: String!
  trackingData: TrackingDataDraftType
}
input SetOrderReturnPaymentState {
  returnItemId: String!
  paymentState: ReturnPaymentState!
}
input SetOrderReturnShipmentState {
  returnItemId: String!
  shipmentState: ReturnShipmentState!
}
input SetOrderShippingAddress {
  address: AddressInput
}
input SetOrderShippingAddressCustomField {
  name: String!
  value: String
}
input SetOrderShippingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetOrderStore {
  store: ResourceIdentifierInput
}
input SetPaymentAmountPaid {
  amount: MoneyInput
}
input SetPaymentAmountRefunded {
  amount: MoneyInput
}
input SetPaymentAnonymousId {
  anonymousId: String
}
input SetPaymentAuthorization {
  amount: MoneyInput
  until: DateTime
}
input SetPaymentCustomField {
  name: String!
  value: String
}
input SetPaymentCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetPaymentCustomer {
  customer: ReferenceInput
}
input SetPaymentExternalId {
  externalId: String
}
input SetPaymentInterfaceId {
  interfaceId: String
}
input SetPaymentKey {
  key: String
}
input SetPaymentMethodInfoInterface {
  interface: String!
}
input SetPaymentMethodInfoMethod {
  method: String
}
input SetPaymentMethodInfoName {
  name: [LocalizedStringItemInputType!]
}
input SetPaymentStatusInterfaceCode {
  interfaceCode: String
}
input SetPaymentStatusInterfaceText {
  interfaceText: String
}
input SetProductAssetCustomField {
  variantId: Int
  sku: String
  staged: Boolean = true
  value: String
  name: String!
  assetKey: String
  assetId: String
}
input SetProductAssetCustomType {
  variantId: Int
  sku: String
  staged: Boolean = true
  typeId: String
  typeKey: String
  type: ResourceIdentifierInput
  fields: [CustomFieldInput!]
  assetKey: String
  assetId: String
}
input SetProductAssetDescription {
  variantId: Int
  sku: String
  staged: Boolean = true
  description: [LocalizedStringItemInputType!]
  assetKey: String
  assetId: String
}
input SetProductAssetKey {
  variantId: Int
  sku: String
  staged: Boolean = true
  assetKey: String
  assetId: String!
}
input SetProductAssetSources {
  variantId: Int
  sku: String
  staged: Boolean = true
  sources: [AssetSourceInput!] = []
  assetKey: String
  assetId: String
}
input SetProductAssetTags {
  variantId: Int
  sku: String
  staged: Boolean = true
  tags: [String!] = []
  assetKey: String
  assetId: String
}
input SetProductAttribute {
  variantId: Int
  sku: String
  name: String!
  value: String
  staged: Boolean = true
}
input SetProductAttributeInAllVariants {
  name: String!
  value: String
  staged: Boolean = true
}
input SetProductCategoryOrderHint {
  categoryId: String!
  orderHint: String
  staged: Boolean = true
}
input SetProductDescription {
  description: [LocalizedStringItemInputType!]
  staged: Boolean = true
}
input SetProductDiscountDescription {
  description: [LocalizedStringItemInputType!]
}
input SetProductDiscountKey {
  key: String
}
input SetProductDiscountValidFrom {
  validFrom: DateTime
}
input SetProductDiscountValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}
input SetProductDiscountValidUntil {
  validUntil: DateTime
}
input SetProductDiscountedPrice {
  priceId: String!
  discounted: DiscountedProductPriceValueInput
  staged: Boolean = true
}
input SetProductImageLabel {
  variantId: Int
  sku: String
  imageUrl: String!
  label: String
  staged: Boolean = true
}
input SetProductKey {
  key: String
}
input SetProductMetaAttributes {
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}
input SetProductMetaDescription {
  metaDescription: [LocalizedStringItemInputType!]
  staged: Boolean = true
}
input SetProductMetaKeywords {
  metaKeywords: [LocalizedStringItemInputType!]
  staged: Boolean = true
}
input SetProductMetaTitle {
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}
input SetProductPriceCustomField {
  priceId: String!
  staged: Boolean = true
  name: String!
  value: String
}
input SetProductPriceCustomType {
  priceId: String!
  staged: Boolean = true
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetProductPrices {
  variantId: Int
  sku: String
  prices: [ProductPriceDataInput!]!
  staged: Boolean = true
}
input SetProductSku {
  variantId: Int!
  sku: String
  staged: Boolean = true
}
input SetProductTaxCategory {
  taxCategory: ResourceIdentifierInput
}
input SetProductVariantKey {
  variantId: Int
  sku: String
  key: String
  staged: Boolean = true
}
input SetProjectSettingsExternalOAuth {
  externalOAuth: ExternalOAuthDraft
}
input SetProjectSettingsShippingRateInputType {
  shippingRateInputType: ShippingRateInputTypeInput
}
input SetReviewAuthorName {
  authorName: String
}
input SetReviewCustomField {
  name: String!
  value: String
}
input SetReviewCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetReviewCustomer {
  customer: ResourceIdentifierInput
}
input SetReviewKey {
  key: String
}
input SetReviewLocale {
  locale: Locale
}
input SetReviewRating {
  rating: Int
}
input SetReviewTarget {
  target: TargetReferenceInput
}
input SetReviewText {
  text: String
}
input SetReviewTitle {
  title: String
}
input SetSearchKeywords {
  searchKeywords: [SearchKeywordInput!]!
  staged: Boolean
}
input SetShippingMethodCustomField {
  name: String!
  value: String
}
input SetShippingMethodCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetShippingMethodDescription {
  description: String
}
input SetShippingMethodKey {
  key: String
}
input SetShippingMethodLocalizedDescription {
  localizedDescription: [LocalizedStringItemInputType!]
}
input SetShippingMethodLocalizedName {
  localizedName: [LocalizedStringItemInputType!]
}
input SetShippingMethodPredicate {
  predicate: String
}
input SetShoppingListAnonymousId {
  anonymousId: String
}
input SetShoppingListCustomField {
  name: String!
  value: String
}
input SetShoppingListCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetShoppingListCustomer {
  customer: ResourceIdentifierInput
}
input SetShoppingListDeleteDaysAfterLastModification {
  deleteDaysAfterLastModification: Int
}
input SetShoppingListDescription {
  description: [LocalizedStringItemInputType!]
}
input SetShoppingListKey {
  key: String
}
input SetShoppingListLineItemCustomField {
  lineItemId: String!
  name: String!
  value: String
}
input SetShoppingListLineItemCustomType {
  lineItemId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetShoppingListSlug {
  slug: [LocalizedStringItemInputType!]
}
input SetShoppingListStore {
  store: ResourceIdentifierInput
}
input SetShoppingListTextLineItemCustomField {
  textLineItemId: String!
  name: String!
  value: String
}
input SetShoppingListTextLineItemCustomType {
  textLineItemId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetShoppingListTextLineItemDescription {
  textLineItemId: String!
  description: [LocalizedStringItemInputType!]
}
input SetStagedOrderBillingAddress {
  address: AddressInput
}
input SetStagedOrderBillingAddressCustomField {
  name: String!
  value: String
}
type SetStagedOrderBillingAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  name: String!
  value: Json
}
input SetStagedOrderBillingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
type SetStagedOrderBillingAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  custom: CustomFieldsCommand!
}
type SetStagedOrderBillingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft
}
input SetStagedOrderCountry {
  country: Country
}
type SetStagedOrderCountryOutput implements StagedOrderUpdateActionOutput {
  type: String!
  country: Country
}
input SetStagedOrderCustomField {
  name: String!
  value: String
}
type SetStagedOrderCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  name: String!
  value: Json
}
input SetStagedOrderCustomLineItemCustomField {
  customLineItemId: String!
  name: String!
  value: String
}
type SetStagedOrderCustomLineItemCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
  name: String!
  value: Json
}
input SetStagedOrderCustomLineItemCustomType {
  customLineItemId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
type SetStagedOrderCustomLineItemCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
  custom: CustomFieldsCommand!
}
input SetStagedOrderCustomLineItemShippingDetails {
  customLineItemId: String!
  shippingDetails: ItemShippingDetailsDraftType
}
type SetStagedOrderCustomLineItemShippingDetailsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
  shippingDetails: ItemShippingDetailsDraftOutput
}
input SetStagedOrderCustomLineItemTaxAmount {
  customLineItemId: String!
  externalTaxAmount: ExternalTaxAmountDraft
}
type SetStagedOrderCustomLineItemTaxAmountOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
  externalTaxAmount: ExternalTaxAmountDraftOutput
}
input SetStagedOrderCustomLineItemTaxRate {
  customLineItemId: String!
  externalTaxRate: ExternalTaxRateDraft
}
type SetStagedOrderCustomLineItemTaxRateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
  externalTaxRate: ExternalTaxRateDraftOutput
}
input SetStagedOrderCustomShippingMethod {
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}
type SetStagedOrderCustomShippingMethodOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shippingMethodName: String!
  shippingRate: ShippingRate!
  taxCategoryResId: ResourceIdentifier
  externalTaxRate: ExternalTaxRateDraftOutput
}
input SetStagedOrderCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
type SetStagedOrderCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  custom: CustomFieldsCommand!
}
input SetStagedOrderCustomerEmail {
  email: String
}
type SetStagedOrderCustomerEmailOutput implements StagedOrderUpdateActionOutput {
  type: String!
  email: String
}
input SetStagedOrderCustomerGroup {
  customerGroup: ResourceIdentifierInput
}
type SetStagedOrderCustomerGroupOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customerGroupResId: CustomerGroupReferenceIdentifier
}
input SetStagedOrderCustomerId {
  customerId: String
}
type SetStagedOrderCustomerIdOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customerId: String
}
input SetStagedOrderDeliveryAddress {
  deliveryId: String!
  address: AddressInput
}
input SetStagedOrderDeliveryAddressCustomField {
  deliveryId: String!
  name: String!
  value: String
}
type SetStagedOrderDeliveryAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String!
  name: String!
  value: Json
}
input SetStagedOrderDeliveryAddressCustomType {
  deliveryId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
type SetStagedOrderDeliveryAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String!
  custom: CustomFieldsCommand!
}
type SetStagedOrderDeliveryAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String!
  address: AddressDraft
}
input SetStagedOrderDeliveryItems {
  deliveryId: String!
  items: [DeliveryItemDraftType!]!
}
type SetStagedOrderDeliveryItemsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  deliveryId: String!
  items: [DeliveryItem!]!
}
input SetStagedOrderItemShippingAddressCustomField {
  addressKey: String!
  name: String!
  value: String
}
type SetStagedOrderItemShippingAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  addressKey: String!
  name: String!
  value: Json
}
input SetStagedOrderItemShippingAddressCustomType {
  addressKey: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
type SetStagedOrderItemShippingAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  addressKey: String!
  custom: CustomFieldsCommand!
}
input SetStagedOrderLineItemCustomField {
  lineItemId: String!
  name: String!
  value: String
}
type SetStagedOrderLineItemCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  name: String!
  value: Json
}
input SetStagedOrderLineItemCustomType {
  lineItemId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
type SetStagedOrderLineItemCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  custom: CustomFieldsCommand!
}
input SetStagedOrderLineItemDistributionChannel {
  lineItemId: String!
  distributionChannel: ResourceIdentifierInput
}
type SetStagedOrderLineItemDistributionChannelOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  distributionChannelResId: ChannelReferenceIdentifier
}
input SetStagedOrderLineItemPrice {
  lineItemId: String!
  externalPrice: BaseMoneyInput
}
type SetStagedOrderLineItemPriceOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  externalPrice: BaseMoney
}
input SetStagedOrderLineItemShippingDetails {
  lineItemId: String!
  shippingDetails: ItemShippingDetailsDraftType
}
type SetStagedOrderLineItemShippingDetailsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  shippingDetails: ItemShippingDetailsDraftOutput
}
input SetStagedOrderLineItemTaxAmount {
  lineItemId: String!
  externalTaxAmount: ExternalTaxAmountDraft
}
type SetStagedOrderLineItemTaxAmountOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  externalTaxAmount: ExternalTaxAmountDraftOutput
}
input SetStagedOrderLineItemTaxRate {
  lineItemId: String!
  externalTaxRate: ExternalTaxRateDraft
}
type SetStagedOrderLineItemTaxRateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  externalTaxRate: ExternalTaxRateDraftOutput
}
input SetStagedOrderLineItemTotalPrice {
  lineItemId: String!
  externalTotalPrice: ExternalLineItemTotalPriceDraft
}
type SetStagedOrderLineItemTotalPriceOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  externalTotalPrice: ExternalLineItemTotalPrice
}
input SetStagedOrderLocale {
  locale: Locale
}
type SetStagedOrderLocaleOutput implements StagedOrderUpdateActionOutput {
  type: String!
  locale: Locale
}
input SetStagedOrderOrderNumber {
  orderNumber: String
}
type SetStagedOrderOrderNumberOutput implements StagedOrderUpdateActionOutput {
  type: String!
  orderNumber: String
}
input SetStagedOrderOrderTotalTax {
  externalTotalGross: MoneyInput
  externalTaxPortions: [TaxPortionDraft!] = []
}
type SetStagedOrderOrderTotalTaxOutput implements StagedOrderUpdateActionOutput {
  type: String!
  externalTotalGross: Money
  externalTaxPortions: [TaxPortion!]!
}
input SetStagedOrderParcelItems {
  parcelId: String!
  items: [DeliveryItemDraftType!]!
}
type SetStagedOrderParcelItemsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  parcelId: String!
  items: [DeliveryItem!]!
}
input SetStagedOrderParcelMeasurements {
  parcelId: String!
  measurements: ParcelMeasurementsDraftType
}
type SetStagedOrderParcelMeasurementsOutput implements StagedOrderUpdateActionOutput {
  type: String!
  parcelId: String!
  measurements: ParcelMeasurements
}
input SetStagedOrderParcelTrackingData {
  parcelId: String!
  trackingData: TrackingDataDraftType
}
type SetStagedOrderParcelTrackingDataOutput implements StagedOrderUpdateActionOutput {
  type: String!
  parcelId: String!
  trackingData: TrackingData
}
input SetStagedOrderReturnPaymentState {
  returnItemId: String!
  paymentState: ReturnPaymentState!
}
type SetStagedOrderReturnPaymentStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  returnItemId: String!
  paymentState: ReturnPaymentState!
}
input SetStagedOrderReturnShipmentState {
  returnItemId: String!
  shipmentState: ReturnShipmentState!
}
type SetStagedOrderReturnShipmentStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  returnItemId: String!
  shipmentState: ReturnShipmentState!
}
input SetStagedOrderShippingAddress {
  address: AddressInput
}
input SetStagedOrderShippingAddressAndCustomShippingMethod {
  address: AddressInput!
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}
type SetStagedOrderShippingAddressAndCustomShippingMethodOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft!
  shippingMethodName: String!
  shippingRate: ShippingRate!
  taxCategoryResId: ResourceIdentifier
  externalTaxRate: ExternalTaxRateDraftOutput
}
input SetStagedOrderShippingAddressAndShippingMethod {
  address: AddressInput!
  shippingMethod: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}
type SetStagedOrderShippingAddressAndShippingMethodOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft!
  shippingMethodResId: ResourceIdentifier
  externalTaxRate: ExternalTaxRateDraftOutput
}
input SetStagedOrderShippingAddressCustomField {
  name: String!
  value: String
}
type SetStagedOrderShippingAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  type: String!
  name: String!
  value: Json
}
input SetStagedOrderShippingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
type SetStagedOrderShippingAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  type: String!
  custom: CustomFieldsCommand!
}
type SetStagedOrderShippingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft
}
input SetStagedOrderShippingMethod {
  shippingMethod: ResourceIdentifierInput
  externalTaxRate: ExternalTaxRateDraft
}
type SetStagedOrderShippingMethodOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shippingMethodResId: ResourceIdentifier
  externalTaxRate: ExternalTaxRateDraftOutput
}
input SetStagedOrderShippingMethodTaxAmount {
  externalTaxAmount: ExternalTaxAmountDraft
}
type SetStagedOrderShippingMethodTaxAmountOutput implements StagedOrderUpdateActionOutput {
  type: String!
  externalTaxAmount: ExternalTaxAmountDraftOutput
}
input SetStagedOrderShippingMethodTaxRate {
  externalTaxRate: ExternalTaxRateDraft
}
type SetStagedOrderShippingMethodTaxRateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  externalTaxRate: ExternalTaxRateDraftOutput
}
input SetStagedOrderShippingRateInput {
  shippingRateInput: ShippingRateInputDraft
}
type SetStagedOrderShippingRateInputOutput implements StagedOrderUpdateActionOutput {
  type: String!
  shippingRateInput: ShippingRateInputDraftOutput
}
input SetStagedOrderStore {
  store: ResourceIdentifierInput
}
type SetStagedOrderStoreOutput implements StagedOrderUpdateActionOutput {
  type: String!
  storeResId: ResourceIdentifier
}
input SetStateDescription {
  description: [LocalizedStringItemInputType!]
}
input SetStateName {
  name: [LocalizedStringItemInputType!]
}
input SetStateRoles {
  roles: [StateRole!]!
}
input SetStateTransitions {
  transitions: [ResourceIdentifierInput!]
}
input SetStoreCustomField {
  name: String!
  value: String
}
input SetStoreCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeKey: String
  typeId: String
}
input SetStoreDistributionChannels {
  distributionChannels: [ResourceIdentifierInput!]
}
input SetStoreLanguages {
  languages: [Locale!]
}
input SetStoreName {
  name: [LocalizedStringItemInputType!]
}
input SetStoreSupplyChannels {
  supplyChannels: [ResourceIdentifierInput!]
}
input SetSubscriptionChanges {
  changes: [ChangeSubscriptionInput!]!
}
input SetSubscriptionKey {
  key: String
}
input SetSubscriptionMessages {
  messages: [MessageSubscriptionInput!]!
}
input SetTaxCategoryKey {
  key: String
}
type SetType implements FieldType {
  elementType: FieldType!
  name: String!
}
input SetTypeDescription {
  description: [LocalizedStringItemInputType!]
}
input SetZoneDescription {
  description: String
}
input SetZoneKey {
  key: String
}
input ShippingMethodDraft {
  name: String!
  localizedName: [LocalizedStringItemInputType!]
  description: String
  localizedDescription: [LocalizedStringItemInputType!]
  taxCategory: ResourceIdentifierInput!
  zoneRates: [ZoneRateDraft!] = []
  isDefault: Boolean!
  predicate: String
  key: String
  custom: CustomFieldsDraft
}
input ShippingMethodUpdateAction {
  addShippingRate: AddShippingMethodShippingRate
  addZone: AddShippingMethodZone
  changeIsDefault: ChangeShippingMethodIsDefault
  changeName: ChangeShippingMethodName
  changeTaxCategory: ChangeShippingMethodTaxCategory
  removeShippingRate: RemoveShippingMethodShippingRate
  removeZone: RemoveShippingMethodZone
  setCustomField: SetShippingMethodCustomField
  setCustomType: SetShippingMethodCustomType
  setDescription: SetShippingMethodDescription
  setKey: SetShippingMethodKey
  setLocalizedDescription: SetShippingMethodLocalizedDescription
  setLocalizedName: SetShippingMethodLocalizedName
  setPredicate: SetShippingMethodPredicate
}
type ShippingRateCartClassificationPriceTier implements ShippingRatePriceTier {
  value: String!
  price: Money!
  isMatching: Boolean
  type: String!
}
type ShippingRateCartScorePriceTier implements ShippingRatePriceTier {
  score: Int!
  price: Money
  priceFunction: PriceFunction
  isMatching: Boolean
  type: String!
}
type ShippingRateCartValuePriceTier implements ShippingRatePriceTier {
  minimumCentAmount: Int!
  price: Money!
  isMatching: Boolean
  type: String!
}
input ShippingRateDraft {
  price: MoneyDraft!
  freeAbove: MoneyDraft
  tiers: [ShippingRatePriceTierDraft!] = []
}
input ShippingRateInputDraft {
  Classification: ClassificationShippingRateInputDraft
  Score: ScoreShippingRateInputDraft
}
interface ShippingRateInputDraftOutput {
  type: String!
}
type ShippingRateInputLocalizedEnumValue {
  key: String!
  label("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  labelAllLocales: [LocalizedString!]!
}
input ShippingRateInputTypeInput {
  CartValue: CartValueInput
  CartClassification: CartClassificationInput
  CartScore: CartScoreInput
}
input ShippingRatePriceTierCartClassificationDraft {
  value: String!
  price: MoneyDraft!
}
input ShippingRatePriceTierCartScoreDraft {
  score: Int!
  price: MoneyDraft
  priceFunction: PriceFunctionDraft
}
input ShippingRatePriceTierCartValueDraft {
  minimumCentAmount: Int!
  price: MoneyDraft!
}
input ShippingRatePriceTierDraft {
  CartValue: ShippingRatePriceTierCartValueDraft
  CartClassification: ShippingRatePriceTierCartClassificationDraft
  CartScore: ShippingRatePriceTierCartScoreDraft
}
type ShippingTarget implements CartDiscountTarget {
  type: String!
}
input ShippingTargetDraft {
  addressKey: String!
  quantity: Long!
}
input ShippingTargetDraftType {
  addressKey: String!
  quantity: Long!
}
input ShippingTargetInput {
  dummy: String
}
input ShoppingListDraft {
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  lineItems: [ShoppingListLineItemDraft!] = []
  textLineItems: [TextLineItemDraft!] = []
  custom: CustomFieldsDraft
  deleteDaysAfterLastModification: Int
  key: String
  customer: ResourceIdentifierInput
  slug: [LocalizedStringItemInputType!]
  anonymousId: String
}
input ShoppingListLineItemDraft {
  productId: String
  sku: String
  variantId: Int
  quantity: Int = 1
  custom: CustomFieldsDraft
  addedAt: DateTime
}
input ShoppingListUpdateAction {
  addLineItem: AddShoppingListLineItem
  addTextLineItem: AddShoppingListTextLineItem
  changeLineItemQuantity: ChangeShoppingListLineItemQuantity
  changeLineItemsOrder: ChangeShoppingListLineItemsOrder
  changeName: ChangeShoppingListName
  changeTextLineItemName: ChangeShoppingListTextLineItemName
  changeTextLineItemQuantity: ChangeShoppingListTextLineItemQuantity
  changeTextLineItemsOrder: ChangeShoppingListTextLineItemsOrder
  removeLineItem: RemoveShoppingListLineItem
  removeTextLineItem: RemoveShoppingListTextLineItem
  setAnonymousId: SetShoppingListAnonymousId
  setCustomField: SetShoppingListCustomField
  setCustomType: SetShoppingListCustomType
  setCustomer: SetShoppingListCustomer
  setDeleteDaysAfterLastModification: SetShoppingListDeleteDaysAfterLastModification
  setDescription: SetShoppingListDescription
  setKey: SetShoppingListKey
  setLineItemCustomField: SetShoppingListLineItemCustomField
  setLineItemCustomType: SetShoppingListLineItemCustomType
  setSlug: SetShoppingListSlug
  setStore: SetShoppingListStore
  setTextLineItemCustomField: SetShoppingListTextLineItemCustomField
  setTextLineItemCustomType: SetShoppingListTextLineItemCustomType
  setTextLineItemDescription: SetShoppingListTextLineItemDescription
}
input ShoppingListsConfigurationInput {
  deleteDaysAfterLastModification: Int
}
input SimpleAttributeTypeDraft {
  dummy: String
}
input SimpleFieldTypeDraft {
  dummy: String
}
input StagedOrderUpdateAction {
  addCustomLineItem: AddStagedOrderCustomLineItem
  addDelivery: AddStagedOrderDelivery
  addDiscountCode: AddStagedOrderDiscountCode
  addItemShippingAddress: AddStagedOrderItemShippingAddress
  addLineItem: AddStagedOrderLineItem
  addParcelToDelivery: AddStagedOrderParcelToDelivery
  addPayment: AddStagedOrderPayment
  addReturnInfo: AddStagedOrderReturnInfo
  addShoppingList: AddStagedOrderShoppingList
  changeCustomLineItemMoney: ChangeStagedOrderCustomLineItemMoney
  changeCustomLineItemQuantity: ChangeStagedOrderCustomLineItemQuantity
  changeLineItemQuantity: ChangeStagedOrderLineItemQuantity
  changeOrderState: ChangeStagedOrderOrderState
  changePaymentState: ChangeStagedOrderPaymentState
  changeShipmentState: ChangeStagedOrderShipmentState
  changeTaxCalculationMode: ChangeStagedOrderTaxCalculationMode
  changeTaxMode: ChangeStagedOrderTaxMode
  changeTaxRoundingMode: ChangeStagedOrderTaxRoundingMode
  importCustomLineItemState: ImportStagedOrderCustomLineItemState
  importLineItemState: ImportStagedOrderLineItemState
  recalculate: RecalculateStagedOrder
  removeCustomLineItem: RemoveStagedOrderCustomLineItem
  removeDelivery: RemoveStagedOrderDelivery
  removeDiscountCode: RemoveStagedOrderDiscountCode
  removeItemShippingAddress: RemoveStagedOrderItemShippingAddress
  removeLineItem: RemoveStagedOrderLineItem
  removeParcelFromDelivery: RemoveStagedOrderParcelFromDelivery
  removePayment: RemoveStagedOrderPayment
  setBillingAddress: SetStagedOrderBillingAddress
  setBillingAddressCustomField: SetStagedOrderBillingAddressCustomField
  setBillingAddressCustomType: SetStagedOrderBillingAddressCustomType
  setCountry: SetStagedOrderCountry
  setCustomField: SetStagedOrderCustomField
  setCustomLineItemCustomField: SetStagedOrderCustomLineItemCustomField
  setCustomLineItemCustomType: SetStagedOrderCustomLineItemCustomType
  setCustomLineItemShippingDetails: SetStagedOrderCustomLineItemShippingDetails
  setCustomLineItemTaxAmount: SetStagedOrderCustomLineItemTaxAmount
  setCustomLineItemTaxRate: SetStagedOrderCustomLineItemTaxRate
  setCustomShippingMethod: SetStagedOrderCustomShippingMethod
  setCustomType: SetStagedOrderCustomType
  setCustomerEmail: SetStagedOrderCustomerEmail
  setCustomerGroup: SetStagedOrderCustomerGroup
  setCustomerId: SetStagedOrderCustomerId
  setDeliveryAddress: SetStagedOrderDeliveryAddress
  setDeliveryAddressCustomField: SetStagedOrderDeliveryAddressCustomField
  setDeliveryAddressCustomType: SetStagedOrderDeliveryAddressCustomType
  setDeliveryItems: SetStagedOrderDeliveryItems
  setItemShippingAddressCustomField: SetStagedOrderItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetStagedOrderItemShippingAddressCustomType
  setLineItemCustomField: SetStagedOrderLineItemCustomField
  setLineItemCustomType: SetStagedOrderLineItemCustomType
  setLineItemDistributionChannel: SetStagedOrderLineItemDistributionChannel
  setLineItemPrice: SetStagedOrderLineItemPrice
  setLineItemShippingDetails: SetStagedOrderLineItemShippingDetails
  setLineItemTaxAmount: SetStagedOrderLineItemTaxAmount
  setLineItemTaxRate: SetStagedOrderLineItemTaxRate
  setLineItemTotalPrice: SetStagedOrderLineItemTotalPrice
  setLocale: SetStagedOrderLocale
  setOrderNumber: SetStagedOrderOrderNumber
  setOrderTotalTax: SetStagedOrderOrderTotalTax
  setParcelItems: SetStagedOrderParcelItems
  setParcelMeasurements: SetStagedOrderParcelMeasurements
  setParcelTrackingData: SetStagedOrderParcelTrackingData
  setReturnPaymentState: SetStagedOrderReturnPaymentState
  setReturnShipmentState: SetStagedOrderReturnShipmentState
  setShippingAddress: SetStagedOrderShippingAddress
  setShippingAddressAndCustomShippingMethod: SetStagedOrderShippingAddressAndCustomShippingMethod
  setShippingAddressAndShippingMethod: SetStagedOrderShippingAddressAndShippingMethod
  setShippingAddressCustomField: SetStagedOrderShippingAddressCustomField
  setShippingAddressCustomType: SetStagedOrderShippingAddressCustomType
  setShippingMethod: SetStagedOrderShippingMethod
  setShippingMethodTaxAmount: SetStagedOrderShippingMethodTaxAmount
  setShippingMethodTaxRate: SetStagedOrderShippingMethodTaxRate
  setShippingRateInput: SetStagedOrderShippingRateInput
  setStore: SetStagedOrderStore
  transitionCustomLineItemState: TransitionStagedOrderCustomLineItemState
  transitionLineItemState: TransitionStagedOrderLineItemState
  transitionState: TransitionStagedOrderState
  updateItemShippingAddress: UpdateStagedOrderItemShippingAddress
  updateSyncInfo: UpdateStagedOrderSyncInfo
}
input StateDraft {
  key: String!
  type: StateType!
  name: [LocalizedStringItemInputType!]
  description: [LocalizedStringItemInputType!]
  initial: Boolean
  roles: [StateRole!]
  transitions: [ReferenceInput!]
}
input StateUpdateAction {
  addRoles: AddStateRoles
  changeInitial: ChangeStateInitial
  changeKey: ChangeStateKey
  changeType: ChangeStateType
  removeRoles: RemoveStateRoles
  setDescription: SetStateDescription
  setName: SetStateName
  setRoles: SetStateRoles
  setTransitions: SetStateTransitions
}
type StoreCreated implements MessagePayload {
  languages: [Locale!]!
  custom: CustomFieldsType
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  distributionChannels: [Channel!]!
  supplyChannels: [Channel!]!
  distributionChannelsRef: [Reference!]!
  supplyChannelsRef: [Reference!]!
  nameAllLocales: [LocalizedString!]
  type: String!
}
type StoreDeleted implements MessagePayload {
  type: String!
}
input StoreUpdateAction {
  addDistributionChannel: AddStoreDistributionChannel
  addSupplyChannel: AddStoreSupplyChannel
  removeDistributionChannel: RemoveStoreDistributionChannel
  removeSupplyChannel: RemoveStoreSupplyChannel
  setCustomField: SetStoreCustomField
  setCustomType: SetStoreCustomType
  setDistributionChannels: SetStoreDistributionChannels
  setLanguages: SetStoreLanguages
  setName: SetStoreName
  setSupplyChannels: SetStoreSupplyChannels
}
type StringAttribute implements Attribute {
  value: String!
  name: String!
}
type StringField implements CustomField {
  value: String!
  name: String!
}
type StringType implements FieldType {
  name: String!
}
input SubRateDraft {
  name: String!
  amount: Float!
}
input SubscriptionDraft {
  key: String
  destination: DestinationInput!
  messages: [MessageSubscriptionInput!]
  changes: [ChangeSubscriptionInput!]
  format: SubscriptionFormatInput
}
input SubscriptionFormatInput {
  Platform: PlatformFormatInput
  CloudEvents: CloudEventsSubscriptionsFormatInput
}
input SubscriptionUpdateAction {
  changeDestination: ChangeSubscriptionDestination
  setChanges: SetSubscriptionChanges
  setKey: SetSubscriptionKey
  setMessages: SetSubscriptionMessages
}
input TargetReferenceInput {
  typeId: String!
  id: String
  key: String
}
input TaxCategoryAddTaxRate {
  taxRate: TaxRateDraft!
}
input TaxCategoryChangeName {
  name: String!
}
input TaxCategoryDraft {
  name: String!
  description: String
  rates: [TaxRateDraft!]
  key: String
}
input TaxCategoryRemoveTaxRate {
  taxRateId: String!
}
input TaxCategoryReplaceTaxRate {
  taxRateId: String!
  taxRate: TaxRateDraft!
}
input TaxCategorySetDescription {
  description: String
}
input TaxCategoryUpdateAction {
  changeName: TaxCategoryChangeName
  setDescription: TaxCategorySetDescription
  addTaxRate: TaxCategoryAddTaxRate
  replaceTaxRate: TaxCategoryReplaceTaxRate
  removeTaxRate: TaxCategoryRemoveTaxRate
  setKey: SetTaxCategoryKey
}
input TaxPortionDraft {
  name: String
  rate: Float!
  amount: MoneyInput!
}
input TaxRateDraft {
  name: String!
  amount: Float
  includedInPrice: Boolean!
  country: Country!
  state: String
  subRates: [SubRateDraft!] = []
}
type TermCount {
  term: String!
  count: Int!
  productCount: Int
}
type TermsFacetResult implements FacetResult {
  dataType: String!
  missing: Int!
  total: Int!
  other: Int!
  terms: [TermCount!]!
  type: String!
}
input TextLineItemDraft {
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  quantity: Int = 1
  custom: CustomFieldsDraft
  addedAt: DateTime
}
"""Time is a scalar value that represents an ISO8601 formatted time."""
scalar Time
type TimeAttribute implements Attribute {
  value: Time!
  name: String!
}
type TimeField implements CustomField {
  value: Time!
  name: String!
}
type TimeType implements FieldType {
  name: String!
}
input TrackingDataDraftType {
  trackingId: String
  carrier: String
  provider: String
  providerTransaction: String
  isReturn: Boolean = false
}
input TransactionDraft {
  timestamp: DateTime
  type: TransactionType!
  amount: MoneyInput!
  interactionId: String
  state: TransactionState
}
input TransitionOrderCustomLineItemState {
  customLineItemId: String!
  quantity: Long!
  fromState: ResourceIdentifierInput!
  toState: ResourceIdentifierInput!
  actualTransitionDate: DateTime
}
input TransitionOrderLineItemState {
  lineItemId: String!
  quantity: Long!
  fromState: ResourceIdentifierInput!
  toState: ResourceIdentifierInput!
  actualTransitionDate: DateTime
}
input TransitionOrderState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}
input TransitionPaymentState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}
input TransitionProductState {
  state: ReferenceInput!
  force: Boolean
}
input TransitionReviewState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}
input TransitionStagedOrderCustomLineItemState {
  customLineItemId: String!
  quantity: Long!
  fromState: ResourceIdentifierInput!
  toState: ResourceIdentifierInput!
  actualTransitionDate: DateTime
}
type TransitionStagedOrderCustomLineItemStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  customLineItemId: String!
  quantity: Long!
  fromStateResId: ResourceIdentifier!
  toStateResId: ResourceIdentifier!
  actualTransitionDate: DateTime
}
input TransitionStagedOrderLineItemState {
  lineItemId: String!
  quantity: Long!
  fromState: ResourceIdentifierInput!
  toState: ResourceIdentifierInput!
  actualTransitionDate: DateTime
}
type TransitionStagedOrderLineItemStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  lineItemId: String!
  quantity: Long!
  fromStateResId: ResourceIdentifier!
  toStateResId: ResourceIdentifier!
  actualTransitionDate: DateTime
}
input TransitionStagedOrderState {
  state: ResourceIdentifierInput!
  force: Boolean = false
}
type TransitionStagedOrderStateOutput implements StagedOrderUpdateActionOutput {
  type: String!
  stateResId: ResourceIdentifier!
  force: Boolean!
}
input TriggerInput {
  resourceTypeId: String!
  actions: [ActionType!]
}
input TypeDefinitionDraft {
  key: String!
  name: [LocalizedStringItemInputType!]!
  description: [LocalizedStringItemInputType!]
  resourceTypeIds: [String!]!
  fieldDefinitions: [FieldDefinitionInput!]
}
input TypeUpdateAction {
  addEnumValue: AddTypeEnumValue
  addFieldDefinition: AddTypeFieldDefinition
  addLocalizedEnumValue: AddTypeLocalizedEnumValue
  changeEnumValueLabel: ChangeTypeEnumValueLabel
  changeEnumValueOrder: ChangeTypeEnumValueOrder
  changeLabel: ChangeTypeLabel
  changeFieldDefinitionOrder: ChangeTypeFieldDefinitionOrder
  changeInputHint: ChangeTypeInputHint
  changeLocalizedEnumValueLabel: ChangeTypeLocalizedEnumValueLabel
  changeLocalizedEnumValueOrder: ChangeTypeLocalizedEnumValueOrder
  changeKey: ChangeTypeKey
  changeName: ChangeTypeName
  removeFieldDefinition: RemoveTypeFieldDefinition
  setDescription: SetTypeDescription
}
input UnpublishProduct {
  dummy: String
}
input UpdateCartItemShippingAddress {
  address: AddressInput!
}
input UpdateOrderItemShippingAddress {
  address: AddressInput!
}
input UpdateOrderSyncInfo {
  channel: ResourceIdentifierInput!
  syncedAt: DateTime
  externalId: String
}
input UpdateStagedOrderItemShippingAddress {
  address: AddressInput!
}
type UpdateStagedOrderItemShippingAddressOutput implements StagedOrderUpdateActionOutput {
  type: String!
  address: AddressDraft!
}
input UpdateStagedOrderSyncInfo {
  channel: ResourceIdentifierInput!
  syncedAt: DateTime
  externalId: String
}
type UpdateStagedOrderSyncInfoOutput implements StagedOrderUpdateActionOutput {
  type: String!
  channelResId: ChannelReferenceIdentifier!
  syncedAt: DateTime
  externalId: String
}
type ValueFacetResult implements FacetResult {
  count: Int!
  productCount: Int
  type: String!
}
type WhitespaceSuggestTokenizer implements SuggestTokenizer {
  type: String!
}
input WhitespaceSuggestTokenizerInput {
  dummy: String
}
type WhitespaceSuggestTokenizerProductSearch implements SuggestTokenizerProductSearch {
  type: String!
}
input ZoneLocation {
  country: Country!
  state: String
}
input ZoneRateDraft {
  zone: ResourceIdentifierInput!
  shippingRates: [ShippingRateDraft!] = []
}
input ZoneUpdateAction {
  addLocation: AddZoneLocation
  changeName: ChangeZoneName
  removeLocation: RemoveZoneLocation
  setDescription: SetZoneDescription
  setKey: SetZoneKey
}
input addAttributeDefinition {
  attributeDefinition: AttributeDefinitionDraft!
}
input addLocalizedEnumValue {
  attributeName: String!
  value: LocalizedEnumValueDraft!
}
input addPlainEnumValue {
  attributeName: String!
  value: PlainEnumValueDraft!
}
input changeAttributeName {
  attributeName: String!
  newAttributeName: String!
}
input changeAttributeOrder {
  attributeDefinitions: [AttributeDefinitionDraft!]!
}
input changeAttributeOrderByName {
  attributeNames: [String!]!
}
input changeDescription {
  description: String!
}
input changeEnumKey {
  attributeName: String!
  key: String!
  newKey: String!
}
input changeInputHint {
  attributeName: String!
  newValue: TextInputHint!
}
input changeIsSearchable {
  attributeName: String!
  isSearchable: Boolean!
}
input changeLabel {
  attributeName: String!
  label: [LocalizedStringItemInputType!]!
}
input changeLocalizedEnumValueLabel {
  attributeName: String!
  newValue: LocalizedEnumValueDraft!
}
input changeLocalizedEnumValueOrder {
  attributeName: String!
  values: [LocalizedEnumValueDraft!]!
}
input changeName {
  name: String!
}
input changePlainEnumValueLabel {
  attributeName: String!
  newValue: PlainEnumValueDraft!
}
input changePlainEnumValueOrder {
  attributeName: String!
  values: [PlainEnumValueDraft!]!
}
input removeAttributeDefinition {
  name: String!
}
input removeEnumValues {
  attributeName: String!
  keys: [String!]!
}
input setInputTip {
  attributeName: String!
  inputTip: [LocalizedStringItemInputType!]
}
input setKey {
  key: String
}
"""API Clients can be used to obtain OAuth 2 access tokens"""
type APIClientWithoutSecret {
  id: String!
  name: String!
  scope: String!
  createdAt: DateTime
  lastUsedAt: Date
}
type APIClientWithoutSecretQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [APIClientWithoutSecret!]!
}
enum ActionType {
  Update
  Create
}
"""A field to access the active cart."""
interface ActiveCartInterface {
  activeCart: Cart
}
"""An address represents a postal address."""
type Address {
  id: String
  streetName: String
  streetNumber: String
  additionalStreetInfo: String
  postalCode: String
  city: String
  region: String
  state: String
  country: Country!
  company: String
  department: String
  building: String
  apartment: String
  pOBox: String
  additionalAddressInfo: String
  externalId: String
  key: String
  phone: String
  mobile: String
  email: String
  fax: String
  title: String
  salutation: String
  firstName: String
  lastName: String
  custom: CustomFieldsType
}
type Asset {
  id: String!
  key: String
  sources: [AssetSource!]!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  tags: [String!]!
  custom: CustomFieldsType
}
type AssetDimensions {
  width: Int!
  height: Int!
}
type AssetSource {
  uri: String!
  key: String
  dimensions: AssetDimensions
  contentType: String
}
enum AttributeConstraint {
  """No constraints are applied to the attribute"""
  None
  """Attribute value should be different in each variant"""
  Unique
  """A set of attributes, that have this constraint, should have different combinations in each variant"""
  CombinationUnique
  """Attribute value should be the same in all variants"""
  SameForAll
}
type AttributeDefinition {
  type: AttributeDefinitionType!
  name: String!
  label("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  isRequired: Boolean!
  attributeConstraint: AttributeConstraint!
  inputTip("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  inputHint: TextInputHint!
  isSearchable: Boolean!
  labelAllLocales: [LocalizedString!]!
  inputTipAllLocales: [LocalizedString!]
}
type AttributeDefinitionResult {
  limit: Int
  offset: Int
  total: Int!
  results: [AttributeDefinition!]!
}
"""(https://docs.commercetools.com/api/projects/productTypes#attributetype)[https://docs.commercetools.com/api/projects/productTypes#attributetype]"""
interface AttributeDefinitionType {
  name: String!
}
interface BaseMoney {
  type: String!
  currencyCode: Currency!
  centAmount: Long!
  fractionDigits: Int!
}
type BooleanAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}
"""A shopping cart holds product variants and can be ordered. Each cart either belongs to a registered customer or is an anonymous cart."""
type Cart implements Versioned {
  customerId: String
  customer: Customer
  customerEmail: String
  anonymousId: String
  lineItems: [LineItem!]!
  customLineItems: [CustomLineItem!]!
  totalPrice: Money!
  taxedPrice: TaxedPrice
  shippingAddress: Address
  billingAddress: Address
  inventoryMode: InventoryMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxCalculationMode: TaxCalculationMode!
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  country: Country
  shippingInfo: ShippingInfo
  discountCodes: [DiscountCodeInfo!]!
  refusedGifts: [CartDiscount!]!
  refusedGiftsRefs: [Reference!]!
  paymentInfo: PaymentInfo
  locale: Locale
  shippingRateInput: ShippingRateInput
  origin: CartOrigin!
  storeRef: KeyReference
  store: Store
  itemShippingAddresses: [Address!]!
  cartState: CartState!
  key: String
  custom: CustomFieldsType
  deleteDaysAfterLastModification: Int
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
"""

Cart discounts are recalculated every time LineItems or CustomLineItems are added or removed from the Cart or an order is created from the cart.

The number of active cart discounts that do not require a discount code (isActive=true and requiresDiscountCode=false) is limited to 100.
      
"""
type CartDiscount implements Versioned {
  cartPredicate: String!
  validFrom: DateTime
  validUntil: DateTime
  stackingMode: StackingMode!
  isActive: Boolean!
  requiresDiscountCode: Boolean!
  sortOrder: String!
  key: String
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  descriptionAllLocales: [LocalizedString!]
  referenceRefs: [Reference!]!
  custom: CustomFieldsType
  value: CartDiscountValue!
  target: CartDiscountTarget
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type CartDiscountLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type CartDiscountLimitsProjection {
  totalActiveWithoutDiscountCodes: CartDiscountLimitWithCurrent!
}
type CartDiscountQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [CartDiscount!]!
}
interface CartDiscountTarget {
  type: String!
}
interface CartDiscountValue {
  type: String!
}
type CartLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type CartLimitsProjection {
  total: CartLimitWithCurrent!
}
enum CartOrigin {
  """The cart was created by the merchant on behalf of the customer"""
  Merchant
  """The cart was created by the customer. This is the default value"""
  Customer
}
"""Fields to access carts. Includes direct access to a single cart and searching for carts."""
interface CartQueryInterface {
  cart(id: String!): Cart
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
}
type CartQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Cart!]!
}
enum CartState {
  """The cart was ordered. No further operations on the cart are allowed."""
  Ordered
  """Anonymous cart whose content was merged into a customers cart on signin. No further operations on the cart are allowed."""
  Merged
  """The cart can be updated and ordered. It is the default state."""
  Active
}
type CartsConfiguration {
  deleteDaysAfterLastModification: Int
  allowAddingUnpublishedProducts: Boolean!
  countryTaxRateFallbackEnabled: Boolean!
}
type Category implements Versioned {
  id: String!
  key: String
  version: Long!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  ancestorsRef: [Reference!]!
  ancestors: [Category!]!
  parentRef: Reference
  parent: Category
  orderHint: String!
  externalId: String
  metaTitle("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaKeywords("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaDescription("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  """Number of staged products in the category subtree."""
  stagedProductCount: Int!
  """Number of direct child categories."""
  childCount: Int!
  """Direct child categories."""
  children: [Category!]
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  assets: [Asset!]!
  custom: CustomFieldsType
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type CategoryLimitsProjection {
  maxCategories: Limit!
}
type CategoryOrderHint {
  categoryId: String!
  orderHint: String!
}
type CategoryOrderHintProductSearch {
  categoryId: String!
  orderHint: String!
}
type CategoryQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Category!]!
}
type CategorySearch {
  id: String!
  key: String
  version: Long!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  ancestorsRef: [Reference!]!
  ancestors: [CategorySearch!]!
  parentRef: Reference
  parent: CategorySearch
  externalId: String
  stagedProductCount: Int!
  childCount: Int!
  productTypeNames: [String!]!
  """Direct child categories."""
  children: [CategorySearch!]!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  orderHint: String!
  assets: [Asset!]!
  custom: CustomFieldsType
}
type CategorySearchResult {
  offset: Int!
  count: Int!
  total: Int!
  results: [CategorySearch!]!
}
type ChangeSubscription {
  resourceTypeId: String!
}
type Channel implements Versioned& ReviewTarget {
  id: String!
  version: Long!
  key: String!
  roles: [ChannelRole!]!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  address: Address
  geoLocation: Geometry
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  reviewRatingStatistics: ReviewRatingStatistics
  custom: CustomFieldsType
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type ChannelQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Channel!]!
}
enum ChannelRole {
  """Role tells that this channel can be used to track inventory entries.Channels with this role can be treated as warehouses"""
  InventorySupply
  """Role tells that this channel can be used to expose products to a specific distribution channel. It can be used by the cart to select a product price."""
  ProductDistribution
  """Role tells that this channel can be used to track order export activities."""
  OrderExport
  """Role tells that this channel can be used to track order import activities."""
  OrderImport
  """This role can be combined with some other roles (e.g. with `InventorySupply`) to represent the fact that this particular channel is the primary/master channel among the channels of the same type."""
  Primary
}
type CommercetoolsSubscription implements Versioned {
  key: String
  destination: Destination!
  messages: [MessageSubscription!]!
  changes: [ChangeSubscription!]!
  format: NotificationFormat!
  status: SubscriptionHealthStatus!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type CommercetoolsSubscriptionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [CommercetoolsSubscription!]!
}
"""[ISO 3166-1](http://en.wikipedia.org/wiki/ISO_3166-1) country code."""
scalar Country
"""Represents a currency. Currencies are identified by their [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm) currency codes."""
scalar Currency
type CustomFieldsType {
  typeRef: Reference!
  type: TypeDefinition
  """This field contains non-typed data."""
  customFieldsRaw("""
The names of the custom fields to include.

If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
""" includeNames: [String!], """
The names of the custom fields to exclude.

If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
""" excludeNames: [String!]): [RawCustomField!]
}
"""A custom line item is a generic item that can be added to the cart but is not bound to a product. You can use it for discounts (negative money), vouchers, complex cart rules, additional services or fees. You control the lifecycle of this item."""
type CustomLineItem {
  id: String!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  money: BaseMoney!
  totalPrice: Money!
  slug: String!
  quantity: Long!
  state: [ItemState!]!
  taxCategory: TaxCategory
  taxCategoryRef: Reference
  taxRate: TaxRate
  taxedPrice: TaxedItemPrice
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  custom: CustomFieldsType
  shippingDetails: ItemShippingDetails
}
type CustomObject implements Versioned {
  container: String!
  key: String!
  value: Json!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type CustomObjectLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type CustomObjectLimitsProjection {
  total: CustomObjectLimitWithCurrent!
}
type CustomObjectQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [CustomObject!]!
}
"""A customer is a person purchasing products. Carts, Orders and Reviews can be associated to a customer."""
type Customer implements Versioned {
  customerNumber: String
  email: String!
  password: String!
  addresses: [Address!]!
  defaultShippingAddressId: String
  defaultBillingAddressId: String
  shippingAddressIds: [String!]!
  billingAddressIds: [String!]!
  isEmailVerified: Boolean!
  customerGroupRef: Reference
  externalId: String
  key: String
  firstName: String
  lastName: String
  middleName: String
  title: String
  locale: Locale
  salutation: String
  dateOfBirth: Date
  companyName: String
  vatId: String
  customerGroup: CustomerGroup
  defaultShippingAddress: Address
  defaultBillingAddress: Address
  shippingAddresses: [Address!]!
  billingAddresses: [Address!]!
  storesRef: [KeyReference!]!
  stores: [Store!]!
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
"""A field to access a customer's active cart."""
interface CustomerActiveCartInterface {
  customerActiveCart(customerId: String!): Cart
}
"""A customer can be a member in a customer group (e.g. reseller, gold member). A customer group can be used in price calculations with special prices being assigned to certain customer groups."""
type CustomerGroup implements Versioned {
  id: String!
  version: Long!
  name: String!
  key: String
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  custom: CustomFieldsType
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type CustomerGroupLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type CustomerGroupLimitsProjection {
  total: CustomerGroupLimitWithCurrent!
}
type CustomerGroupQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [CustomerGroup!]!
}
type CustomerLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type CustomerLimitsProjection {
  total: CustomerLimitWithCurrent!
}
"""Fields to access customer accounts. Includes direct access to a single customer and searching for customers."""
interface CustomerQueryInterface {
  customer("""Queries a customer with specified email token""" emailToken: String, """Queries a customer with specified password token""" passwordToken: String, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Customer
  customers(where: String, sort: [String!], limit: Int, offset: Int): CustomerQueryResult!
}
type CustomerQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Customer!]!
}
"""DateTime is a scalar value that represents an ISO8601 formatted date."""
scalar Date
type DateAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}
"""DateTime is a scalar value that represents an ISO8601 formatted date and time."""
scalar DateTime
type DateTimeAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}
type Delivery {
  id: String!
  createdAt: DateTime!
  items: [DeliveryItem!]!
  parcels: [Parcel!]!
  address: Address
}
type DeliveryItem {
  id: String!
  quantity: Long!
}
interface Destination {
  type: String!
}
type Dimensions {
  width: Int!
  height: Int!
}
type DimensionsProductSearch {
  width: Int!
  height: Int!
}
"""With discount codes it is possible to give specific cart discounts to an eligible amount of users. They are defined by a string value which can be added to a cart so that specific cart discounts can be applied to the cart."""
type DiscountCode implements Versioned {
  code: String!
  isActive: Boolean!
  maxApplications: Long
  maxApplicationsPerCustomer: Long
  cartPredicate: String
  applicationVersion: Long
  validFrom: DateTime
  validUntil: DateTime
  groups: [String!]!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  cartDiscounts: [CartDiscount!]!
  referenceRefs: [Reference!]!
  nameAllLocales: [LocalizedString!]
  descriptionAllLocales: [LocalizedString!]
  custom: CustomFieldsType
  """How many times this discount code was applied (only applications that were part of a successful checkout are considered)"""
  applicationCount: Long!
  cartDiscountRefs: [Reference!]!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type DiscountCodeInfo {
  discountCodeRef: Reference!
  state: DiscountCodeState
  discountCode: DiscountCode
}
type DiscountCodeQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [DiscountCode!]!
}
enum DiscountCodeState {
  """The discount code is active and none of the discounts were applied because the discount application was stopped by one discount that has the StackingMode of StopAfterThisDiscount defined"""
  ApplicationStoppedByPreviousDiscount
  """The discount code is not valid or it does not contain any valid cart discounts. Validity is determined based on the validFrom and validUntil dates"""
  NotValid
  """maxApplications or maxApplicationsPerCustomer for discountCode has been reached."""
  MaxApplicationReached
  """The discount code is active and it contains at least one active and valid CartDiscount. The discount code cartPredicate matches the cart and at least one of the contained active discount’s cart predicates matches the cart."""
  MatchesCart
  """The discount code is active and it contains at least one active and valid CartDiscount. But its cart predicate does not match the cart or none of the contained active discount’s cart predicates match the cart"""
  DoesNotMatchCart
  """The discount code is not active or it does not contain any active cart discounts."""
  NotActive
}
type DiscountedLineItemPortion {
  discount: CartDiscount
  discountRef: Reference!
  discountedAmount: BaseMoney!
}
type DiscountedLineItemPrice {
  value: BaseMoney!
  includedDiscounts: [DiscountedLineItemPortion!]!
}
type DiscountedLineItemPriceForQuantity {
  quantity: Long!
  discountedPrice: DiscountedLineItemPrice!
}
type DiscountedProductPriceValue {
  value: BaseMoney!
  discountRef: Reference!
  discount: ProductDiscount
}
type DiscountedProductSearchPriceValue {
  value: BaseMoney!
  discountRef: Reference!
  discount: ProductDiscount
}
type EnumAttributeDefinitionType implements AttributeDefinitionType {
  values("""
The keys of the enum values to include.

If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
""" includeKeys: [String!], """
The keys of the enum values to exclude.

If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
""" excludeKeys: [String!], limit: Int, offset: Int, sort: [String!]): PlainEnumValueResult!
  name: String!
}
input ExistsFilterInput {
  path: String!
}
type Extension implements Versioned {
  key: String
  destination: ExtensionDestination!
  triggers: [Trigger!]!
  timeoutInMs: Int
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
interface ExtensionDestination {
  type: String!
}
type ExtensionLimitsProjection {
  timeoutInMs: Limit!
}
type ExtensionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Extension!]!
}
type ExternalOAuth {
  url: String!
  authorizationHeader: String!
}
interface FacetResult {
  type: String!
}
type FacetResultValue {
  facet: String!
  value: FacetResult!
}
"""Field definitions describe custom fields and allow you to define some meta-information associated with the field."""
type FieldDefinition {
  name: String!
  required: Boolean!
  inputHint: TextInputHint!
  label("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  labelAllLocales: [LocalizedString!]!
  type: FieldType!
}
interface FieldType {
  name: String!
}
interface Geometry {
  type: String!
}
type Image {
  url: String!
  dimensions: Dimensions!
  label: String
}
type ImageProductSearch {
  url: String!
  dimensions: DimensionsProductSearch!
  label: String
}
type InStore implements CartQueryInterface& CustomerActiveCartInterface& OrderQueryInterface& CustomerQueryInterface& ShippingMethodsByCartInterface& MeFieldInterface {
  """
  This field can only be used with an access token created with the password flow or with an anonymous session.

It gives access to the data that is specific to the customer or the anonymous session linked to the access token.
  """
  me: InStoreMe!
  shippingMethodsByCart(id: String!): [ShippingMethod!]!
  customer("""Queries a customer with specified email token""" emailToken: String, """Queries a customer with specified password token""" passwordToken: String, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Customer
  customers(where: String, sort: [String!], limit: Int, offset: Int): CustomerQueryResult!
  cart(id: String!): Cart
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  customerActiveCart(customerId: String!): Cart
  order("""Queries with specified ID""" id: String, orderNumber: String): Order
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
  shoppingList("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
}
type InStoreMe implements MeQueryInterface& CartQueryInterface& ActiveCartInterface& OrderQueryInterface& ShoppingListQueryInterface {
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  customer: Customer
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  cart(id: String!): Cart
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  activeCart: Cart
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  order("""Queries with specified ID""" id: String, orderNumber: String): Order
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  shoppingList("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
}
type Initiator {
  isPlatformClient: Boolean
  externalUserId: String
  anonymousId: String
  clientId: String
  customerRef: Reference
  userRef: Reference
}
type InterfaceInteractionsRaw {
  typeRef: Reference!
  type: TypeDefinition
  fields("""
The names of the custom fields to include.

If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
""" includeNames: [String!], """
The names of the custom fields to exclude.

If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
""" excludeNames: [String!]): [RawCustomField!]!
}
type InterfaceInteractionsRawResult {
  limit: Int
  offset: Int
  total: Int!
  results: [InterfaceInteractionsRaw!]!
}
"""Inventory allows you to track stock quantity per SKU and optionally per supply channel"""
type InventoryEntry implements Versioned {
  sku: String!
  quantityOnStock: Long!
  availableQuantity: Long!
  key: String
  restockableInDays: Int
  expectedDelivery: DateTime
  supplyChannel: Channel
  supplyChannelRef: Reference
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type InventoryEntryQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [InventoryEntry!]!
}
enum InventoryMode {
  """
  Adding items to cart and ordering is independent of inventory. No inventory checks or modifications.
This is the default mode for a new cart.
  """
  None
  """
  Creating an order will fail with an OutOfStock error if an unavailable line item exists. Line items in the cart
are only reserved for the duration of the ordering transaction.
  """
  ReserveOnOrder
  """
  Orders are tracked on inventory. That means, ordering a LineItem will decrement the available quantity on the
respective InventoryEntry. Creating an order will succeed even if the line item’s available quantity is zero or
negative. But creating an order will fail with an OutOfStock error if no matching inventory entry exists for a
line item.
  """
  TrackOnly
}
type ItemShippingDetails {
  targets: [ItemShippingTarget!]!
  valid: Boolean!
}
type ItemShippingTarget {
  addressKey: String!
  quantity: Long!
}
type ItemState {
  quantity: Long!
  stateRef: Reference!
  state: State
}
"""Raw JSON value"""
scalar Json
type KeyReference {
  typeId: String!
  key: String!
}
"""A key that references a resource."""
scalar KeyReferenceInput
type Limit {
  limit: Long
}
interface LimitWithCurrent {
  limit: Long
  current: Long
}
"""
A line item is a snapshot of a product variant at the time it was added to the cart.

Since a product variant may change at any time, the ProductVariant data is copied into the field variant.
The relation to the Product is kept but the line item will not automatically update if the product variant changes.
On the cart, the line item can be updated manually. The productSlug refers to the current version of the product.
It can be used to link to the product. If the product has been deleted, the line item remains but refers to a
non-existent product and the productSlug is left empty.

Please also note that creating an order is impossible if the product or product variant a line item relates to has been deleted.
"""
type LineItem {
  id: String!
  productId: String!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  productSlug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  productSlugAllLocales: [LocalizedString!]
  productType: ProductTypeDefinition
  productTypeRef: Reference
  variant: ProductVariant
  price: ProductPrice!
  taxedPrice: TaxedItemPrice
  totalPrice: Money
  quantity: Long!
  addedAt: DateTime
  lastModifiedAt: DateTime
  state: [ItemState!]!
  taxRate: TaxRate
  supplyChannel: Channel
  supplyChannelRef: Reference
  distributionChannel: Channel
  distributionChannelRef: Reference
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  lineItemMode: LineItemMode!
  priceMode: LineItemPriceMode!
  custom: CustomFieldsType
  shippingDetails: ItemShippingDetails
  inventoryMode: ItemShippingDetails
}
enum LineItemMode {
  """
  The line item was added automatically, because a discount has added a free gift to the cart.
The quantity can not be increased, and it won’t be merged when the same product variant is added.
If the gift is removed, an entry is added to the "refusedGifts" array and the discount won’t be applied again
to the cart. The price can not be changed externally.
All other updates, such as the ones related to custom fields, can be used.
  """
  GiftLineItem
  """
  The line item was added during cart creation or with the update action addLineItem. Its quantity can be
changed without restrictions.
  """
  Standard
}
enum LineItemPriceMode {
  """The price is selected form the product variant. This is the default mode."""
  Platform
  """The line item price was set externally. Cart discounts can apply to line items with this price mode. All update actions that change the quantity of a line item with this price mode require the externalPrice field to be given."""
  ExternalPrice
  """The line item price with the total was set externally."""
  ExternalTotal
}
"""Locale is a scalar value represented as a string language tag."""
scalar Locale
type LocalizableEnumAttributeDefinitionType implements AttributeDefinitionType {
  values("""
The keys of the enum values to include.

If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
""" includeKeys: [String!], """
The keys of the enum values to exclude.

If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
""" excludeKeys: [String!], limit: Int, offset: Int, sort: [String!]): LocalizableEnumValueTypeResult!
  name: String!
}
type LocalizableEnumValueType {
  key: String!
  label("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  labelAllLocales: [LocalizedString!]!
}
type LocalizableEnumValueTypeResult {
  limit: Int
  offset: Int
  total: Int!
  results: [LocalizableEnumValueType!]!
}
type LocalizableTextAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}
type LocalizedString {
  locale: Locale!
  value: String!
}
input LocalizedText {
  text: String!
  locale: Locale!
}
type Location {
  country: Country!
  state: String
}
type Me implements MeQueryInterface& CartQueryInterface& ActiveCartInterface& OrderQueryInterface& ShoppingListQueryInterface {
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  customer: Customer
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  cart(id: String!): Cart
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  activeCart: Cart
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  order("""Queries with specified ID""" id: String, orderNumber: String): Order
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  shoppingList("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  payment(id: String!): MyPayment
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  payments(where: String, sort: [String!], limit: Int, offset: Int): MyPaymentQueryResult!
}
"""The me field gives access to the data that is specific to the customer or anonymous session linked to the access token."""
interface MeFieldInterface {
  me: MeQueryInterface!
}
interface MeQueryInterface {
  cart(id: String!): Cart
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  activeCart: Cart
  order("""Queries with specified ID""" id: String, orderNumber: String): Order
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
  shoppingList("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
}
type Message implements Versioned {
  id: String!
  type: String!
  sequenceNumber: Long!
  resourceRef: Reference!
  resourceVersion: Long!
  userProvidedIdentifiers: UserProvidedIdentifiers
  payload: MessagePayload!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
interface MessagePayload {
  type: String!
}
type MessageQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Message!]!
}
type MessageSubscription {
  resourceTypeId: String!
  types: [String!]!
}
type MessagesConfiguration {
  enabled: Boolean!
  deleteDaysAfterCreation: Int
}
input MissingFacetInput {
  path: String!
  alias: String
}
input MissingFilterInput {
  path: String!
}
type Money implements BaseMoney {
  type: String!
  currencyCode: Currency!
  centAmount: Long!
  """For the `Money` it equals to the default number of fraction digits used with the currency."""
  fractionDigits: Int!
}
type MoneyAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}
"""
My Payments endpoint provides access to payments scoped to a specific user.
[documentation](https://docs.commercetools.com/http-api-projects-me-payments#mypayment)
"""
type MyPayment {
  id: String!
  version: Long!
  customerRef: Reference
  customer: Customer
  anonymousId: String
  paymentMethodInfo: PaymentMethodInfo!
  amountPlanned: Money!
  transactions: [Transaction!]!
  custom: CustomFieldsType
}
type MyPaymentQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [MyPayment!]!
}
type NestedAttributeDefinitionType implements AttributeDefinitionType {
  typeRef: Reference!
  name: String!
}
interface NotificationFormat {
  type: String!
}
type NumberAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}
"""
An order can be created from a cart, usually after a checkout process has been completed.
[documentation](https://docs.commercetools.com/http-api-projects-orders.html)
"""
type Order implements Versioned {
  customerId: String
  customer: Customer
  customerEmail: String
  anonymousId: String
  lineItems: [LineItem!]!
  customLineItems: [CustomLineItem!]!
  totalPrice: Money!
  taxedPrice: TaxedPrice
  shippingAddress: Address
  billingAddress: Address
  inventoryMode: InventoryMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxCalculationMode: TaxCalculationMode!
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  country: Country
  shippingInfo: ShippingInfo
  discountCodes: [DiscountCodeInfo!]!
  refusedGifts: [CartDiscount!]!
  refusedGiftsRefs: [Reference!]!
  paymentInfo: PaymentInfo
  locale: Locale
  shippingRateInput: ShippingRateInput
  origin: CartOrigin!
  storeRef: KeyReference
  store: Store
  itemShippingAddresses: [Address!]!
  completedAt: DateTime
  orderNumber: String
  orderState: OrderState!
  stateRef: Reference
  state: State
  shipmentState: ShipmentState
  paymentState: PaymentState
  syncInfo: [SyncInfo!]!
  returnInfo: [ReturnInfo!]!
  lastMessageSequenceNumber: Long!
  cartRef: Reference
  cart: Cart
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type OrderEdit implements Versioned {
  key: String
  resourceRef: Reference!
  resource: Order
  stagedActions: [StagedOrderUpdateActionOutput!]!
  result: OrderEditResult!
  comment: String
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type OrderEditLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type OrderEditLimitsProjection {
  total: OrderEditLimitWithCurrent!
}
type OrderEditQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [OrderEdit!]!
}
interface OrderEditResult {
  type: String!
}
"""Fields to access orders. Includes direct access to a single order and searching for orders."""
interface OrderQueryInterface {
  order("""Queries with specified ID""" id: String, orderNumber: String): Order
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
}
type OrderQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Order!]!
}
type OrderSearchConfiguration {
  status: OrderSearchStatus!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
}
enum OrderSearchStatus {
  Activated
  Deactivated
}
enum OrderState {
  Confirmed
  Cancelled
  Complete
  Open
}
type Parcel {
  id: String!
  createdAt: DateTime!
  measurements: ParcelMeasurements
  trackingData: TrackingData
  items: [DeliveryItem!]!
}
type ParcelMeasurements {
  heightInMillimeter: Int
  lengthInMillimeter: Int
  widthInMillimeter: Int
  weightInGram: Int
}
"""
Payments hold information about the current state of receiving and/or refunding money.
[documentation](https://docs.commercetools.com/http-api-projects-payments)
"""
type Payment implements Versioned {
  key: String
  customerRef: Reference
  customer: Customer
  anonymousId: String
  interfaceId: String
  amountPlanned: Money!
  paymentMethodInfo: PaymentMethodInfo!
  paymentStatus: PaymentStatus!
  transactions: [Transaction!]!
  interfaceInteractionsRaw(limit: Int, offset: Int): InterfaceInteractionsRawResult!
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type PaymentInfo {
  payments: [Payment!]!
  paymentRefs: [Reference!]!
}
type PaymentMethodInfo {
  paymentInterface: String
  method: String
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
}
type PaymentQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Payment!]!
}
enum PaymentState {
  Paid
  CreditOwed
  Pending
  Failed
  BalanceDue
}
type PaymentStatus {
  interfaceCode: String
  interfaceText: String
  stateRef: Reference
  state: State
}
type PlainEnumValue {
  key: String!
  label: String!
}
type PlainEnumValueResult {
  limit: Int
  offset: Int
  total: Int!
  results: [PlainEnumValue!]!
}
input PriceSelectorInput {
  currency: Currency!
  country: Country
  customerGroup: ReferenceInput
  channel: ReferenceInput
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  date: DateTime!
}
type Product implements Versioned& ReviewTarget {
  id: String!
  key: String
  version: Long!
  productTypeRef: Reference!
  productType: ProductTypeDefinition
  masterData: ProductCatalogData!
  skus: [String!]!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  stateRef: Reference
  state: State
  taxCategoryRef: Reference
  taxCategory: TaxCategory
  reviewRatingStatistics: ReviewRatingStatistics
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type ProductCatalogData {
  current: ProductData
  staged: ProductData
  published: Boolean!
  hasStagedChanges: Boolean!
}
type ProductData {
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  descriptionAllLocales: [LocalizedString!]
  slug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  categoryOrderHint(categoryId: String!): String
  categoryOrderHints: [CategoryOrderHint!]!
  categoriesRef: [Reference!]!
  categories: [Category!]!
  searchKeyword("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale!): [SearchKeyword!]
  searchKeywords: [SearchKeywords!]!
  metaTitle("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaKeywords("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaDescription("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  masterVariant: ProductVariant!
  variants("""Queries for products with specified SKUs""" skus: [String!], isOnStock: Boolean, """
The IDs of channels for which to check the stock of the `isOnStock`.

Variant is returned if at least one of the channels is matching the `isOnStock`

If the list is not provided then noChannel is checked for `isOnStock`
""" stockChannelIds: [String!], hasImages: Boolean): [ProductVariant!]!
  allVariants("""Queries for products with specified SKUs""" skus: [String!], isOnStock: Boolean, """
The IDs of channels for which to check the stock of the `isOnStock`.

Variant is returned if at least one of the channels is matching the `isOnStock`

If the list is not provided then noChannel is checked for `isOnStock`
""" stockChannelIds: [String!], hasImages: Boolean): [ProductVariant!]!
  variant("""Queries for a variant with specified SKU""" sku: String, """Queries for a variant with specified [key](https://docs.commercetools.com/api/projects/products#variant_key)""" key: String): ProductVariant
  skus: [String!]!
}
"""

A product price can be discounted in two ways:

* with a relative or an absolute product discount, which will be automatically applied to all prices in a product that match a discount predicate.
  A relative discount reduces the matching price by a fraction (for example 10 % off). An absolute discount reduces the matching price by a fixed amount (for example 10€ off). If more than one product discount matches a price, the discount sort order determines which one will be applied.
* with an external product discount, which can then be used to explicitly set a discounted value on a particular product price.

The discounted price is stored in the discounted field of the Product Price.

Note that when a discount is created, updated or removed it can take up to 15 minutes to update all the prices with the discounts.

The maximum number of ProductDiscounts that can be active at the same time is **200**.
      
"""
type ProductDiscount implements Versioned {
  predicate: String!
  validFrom: DateTime
  validUntil: DateTime
  isActive: Boolean!
  isValid: Boolean!
  sortOrder: String!
  key: String
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  referenceRefs: [Reference!]!
  nameAllLocales: [LocalizedString!]!
  descriptionAllLocales: [LocalizedString!]
  value: ProductDiscountValue!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type ProductDiscountLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type ProductDiscountLimitsProjection {
  totalActive: ProductDiscountLimitWithCurrent!
}
type ProductDiscountQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [ProductDiscount!]!
}
interface ProductDiscountValue {
  type: String!
}
type ProductLimitsProjection {
  pricesPerVariant: Limit!
  variants: Limit!
}
type ProductPrice {
  id: String
  value: BaseMoney!
  country: Country
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  channel: Channel
  channelRef: Reference
  validFrom: DateTime
  validUntil: DateTime
  discounted: DiscountedProductPriceValue
  tiers: [ProductPriceTier!]
  custom: CustomFieldsType
}
type ProductPriceSearch {
  id: String
  value: BaseMoney!
  country: Country
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  channel: Channel
  channelRef: Reference
  validFrom: DateTime
  validUntil: DateTime
  discounted: DiscountedProductSearchPriceValue
  tiers: [ProductSearchPriceTier!]
  custom: CustomFieldsType
}
type ProductPriceTier {
  minimumQuantity: Int!
  value: BaseMoney!
}
type ProductProjection {
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  productTypeRef: Reference!
  productType: ProductTypeDefinition
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]!
  categoryOrderHints: [CategoryOrderHintProductSearch!]!
  categoriesRef: [Reference!]!
  categories: [Category!]!
  searchKeywords: [SearchKeywordsProductSearch!]!
  metaTitle("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaTitleAllLocales: [LocalizedString!]
  metaKeywords("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaDescription("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  metaDescriptionAllLocales: [LocalizedString!]
  hasStagedChanges: Boolean!
  published: Boolean!
  masterVariant: ProductSearchVariant!
  variants: [ProductSearchVariant!]!
  taxCategoryRef: Reference
  taxCategory: TaxCategory
  stateRef: Reference
  state: State
  reviewRatingStatistics: ReviewRatingStatistics
}
type ProductProjectionSearchResult {
  offset: Int!
  count: Int!
  total: Int!
  results: [ProductProjection!]!
  facets: [FacetResultValue!]!
}
type ProductQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Product!]!
}
type ProductSearchPriceTier {
  minimumQuantity: Int!
  value: BaseMoney!
}
type ProductSearchVariant {
  id: Int!
  key: String
  sku: String
  prices: [ProductPriceSearch!]
  """Returns a single price based on the price selection rules."""
  price(currency: Currency!, country: Country, customerGroupId: String, channelId: String, date: DateTime): ProductPriceSearch
  images: [ImageProductSearch!]!
  assets: [Asset!]!
  availability: ProductSearchVariantAvailabilityWithChannels
  """This field contains raw attributes data"""
  attributesRaw("""
The names of the attributes to include.

If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
""" includeNames: [String!], """
The names of the attributes to exclude.

If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
""" excludeNames: [String!]): [RawProductSearchAttribute!]!
}
"""Product variant availabilities"""
type ProductSearchVariantAvailabilitiesResult {
  limit: Int
  offset: Int
  total: Int!
  results: [ProductSearchVariantAvailabilityWithChannel!]!
}
"""Product variant availability"""
type ProductSearchVariantAvailability {
  isOnStock: Boolean!
  restockableInDays: Int
  availableQuantity: Long
  version: Long
  id: String
}
type ProductSearchVariantAvailabilityWithChannel {
  channelRef: Reference!
  channel: Channel
  availability: ProductSearchVariantAvailability!
}
type ProductSearchVariantAvailabilityWithChannels {
  noChannel: ProductSearchVariantAvailability
  channels("""
The IDs of channels to include.

If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
""" includeChannelIds: [String!], """
The IDs of channels to exclude.

If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
""" excludeChannelIds: [String!], limit: Int, offset: Int): ProductSearchVariantAvailabilitiesResult!
}
type ProductTypeDefinition implements Versioned {
  key: String
  name: String!
  description: String!
  attributeDefinitions("""
The names of the attribute definitions to include.

If neither `includeNames` nor `excludeNames` are provided, then all attribute definitions are returned.
""" includeNames: [String!], """
The names of the attribute definitions to exclude.

If neither `includeNames` nor `excludeNames` are provided, then all attribute definitions are returned.
""" excludeNames: [String!], limit: Int, offset: Int, sort: [String!]): AttributeDefinitionResult!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type ProductTypeDefinitionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [ProductTypeDefinition!]!
}
type ProductTypeLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type ProductTypeLimitsProjection {
  total: ProductTypeLimitWithCurrent!
}
type ProductVariant {
  id: Int!
  key: String
  sku: String
  prices: [ProductPrice!]
  """Returns a single price based on the price selection rules."""
  price(currency: Currency!, country: Country, customerGroupId: String, channelId: String, date: DateTime): ProductPrice
  images: [Image!]!
  assets: [Asset!]!
  availability: ProductVariantAvailabilityWithChannels
  """This field contains raw attributes data"""
  attributesRaw("""
The names of the attributes to include.

If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
""" includeNames: [String!], """
The names of the attributes to exclude.

If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
""" excludeNames: [String!]): [RawProductAttribute!]!
}
"""Product variant availabilities"""
type ProductVariantAvailabilitiesResult {
  limit: Int
  offset: Int
  total: Int!
  results: [ProductVariantAvailabilityWithChannel!]!
}
"""Product variant availability"""
type ProductVariantAvailability {
  isOnStock: Boolean!
  restockableInDays: Int
  availableQuantity: Long
  version: Long
  id: String
}
type ProductVariantAvailabilityWithChannel {
  channelRef: Reference!
  channel: Channel
  availability: ProductVariantAvailability!
}
type ProductVariantAvailabilityWithChannels {
  noChannel: ProductVariantAvailability
  channels("""
The IDs of channels to include.

If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
""" includeChannelIds: [String!], """
The IDs of channels to exclude.

If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
""" excludeChannelIds: [String!], limit: Int, offset: Int): ProductVariantAvailabilitiesResult!
}
"""Contains information about the limits of your project."""
type ProjectCustomLimitsProjection {
  query: QueryLimitsProjection!
  products: ProductLimitsProjection!
  shoppingLists: ShoppingListLimitsProjection!
  extensions: ExtensionLimitsProjection!
  productDiscounts: ProductDiscountLimitsProjection!
  cartDiscounts: CartDiscountLimitsProjection!
  orderEdits: OrderEditLimitsProjection!
  stores: StoreLimitsProjection!
  customers: CustomerLimitsProjection!
  customerGroups: CustomerGroupLimitsProjection!
  zones: ZoneLimitsProjection!
  taxCategories: TaxCategoryLimitsProjection!
  refreshTokens: RefreshTokenLimitsProjection!
  shippingMethods: ShippingMethodLimitsProjection!
  carts: CartLimitsProjection!
  customObjects: CustomObjectLimitsProjection!
  search: SearchLimitsProjection!
  category: CategoryLimitsProjection!
  productType: ProductTypeLimitsProjection!
}
"""Project contains information about project."""
type ProjectProjection {
  key: String!
  name: String!
  languages: [Locale!]!
  createdAt: DateTime!
  trialUntil: YearMonth
  carts: CartsConfiguration!
  shoppingLists: ShoppingListsConfiguration!
  version: Long!
  externalOAuth: ExternalOAuth
  searchIndexing: SearchIndexingConfiguration
  messages: MessagesConfiguration!
  countries: [Country!]!
  currencies: [Currency!]!
  shippingRateInputType: ShippingRateInputType
}
type Query implements CartQueryInterface& CustomerActiveCartInterface& OrderQueryInterface& CustomerQueryInterface& ShoppingListQueryInterface& ShippingMethodsByCartInterface& MeFieldInterface {
  """
  This field can only be used with an access token created with the password flow or with an anonymous session.

It gives access to the data that is specific to the customer or the anonymous session linked to the access token.
  """
  me: Me!
  """This field gives access to the resources (such as carts) that are inside the given store. Currently in beta."""
  inStore(key: KeyReferenceInput!): InStore!
  """This field gives access to the resources (such as carts) that are inside one of the given stores. Currently in beta."""
  inStores(keys: [KeyReferenceInput!]!): InStore!
  customerGroup("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): CustomerGroup
  customerGroups(where: String, sort: [String!], limit: Int, offset: Int): CustomerGroupQueryResult!
  category("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): Category
  categories(where: String, sort: [String!], limit: Int, offset: Int): CategoryQueryResult!
  """Autocomplete the categories based on category fields like name, description, etc."""
  categoryAutocomplete("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale!, """Incomplete user input.""" text: String!, limit: Int = 10, offset: Int = 0, """
Filters to apply during the search and autocomplete - supported fields are:
* `id`
* `slug`
* `externalId`
* `key`
* `ancestors`
* `parent.id`
* `level`
* `createdAt`
* `modifiedAt`
* `name.{language}:missing`
* `externalId:missing`
* `description.{language}:missing`
* `childCount`
* `productCount`
* `productTypeNames`
""" filters: [SearchFilter!]): CategorySearchResult!
  """Search the categories using full-text search, filtering and sorting"""
  categorySearch("""Full-text search input.""" fulltext: LocalizedText, limit: Int = 10, offset: Int = 0, """Filters to apply before the results of facets""" queryFilters: [SearchFilter!], """
Filters to apply during the search and autocomplete - supported fields are:
* `id`
* `slug`
* `externalId`
* `key`
* `ancestors`
* `parent.id`
* `level`
* `createdAt`
* `modifiedAt`
* `name.{language}:missing`
* `externalId:missing`
* `description.{language}:missing`
* `childCount`
* `productCount`
* `productTypeNames`
""" filters: [SearchFilter!], """
Sort result - supported fields are:

* `id`
* `name`
* `createdAt`
* `modifiedAt`

by default sorted by relevance (a score of matches against the search term in descending order)
""" sorts: [SearchSort!]): CategorySearchResult!
  channel("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): Channel
  channels(where: String, sort: [String!], limit: Int, offset: Int): ChannelQueryResult!
  customObject("""Queries with specified ID""" id: String, """Queries with specified key""" key: String, container: String): CustomObject
  customObjects(where: String, sort: [String!], limit: Int, offset: Int, container: String!): CustomObjectQueryResult!
  productType("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): ProductTypeDefinition
  productTypes(where: String, sort: [String!], limit: Int, offset: Int): ProductTypeDefinitionQueryResult!
  typeDefinition("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): TypeDefinition
  typeDefinitions(where: String, sort: [String!], limit: Int, offset: Int): TypeDefinitionQueryResult!
  shippingMethod("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShippingMethod
  shippingMethods(where: String, sort: [String!], limit: Int, offset: Int): ShippingMethodQueryResult!
  shippingMethodsByCart(id: String!): [ShippingMethod!]!
  shippingMethodsByLocation(country: Country!, state: String, currency: Currency): [ShippingMethod!]!
  zone("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): Zone
  zones(where: String, sort: [String!], limit: Int, offset: Int): ZoneQueryResult!
  taxCategory("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): TaxCategory
  taxCategories(where: String, sort: [String!], limit: Int, offset: Int): TaxCategoryQueryResult!
  discountCode(id: String!): DiscountCode
  discountCodes(where: String, sort: [String!], limit: Int, offset: Int): DiscountCodeQueryResult!
  cartDiscount("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): CartDiscount
  cartDiscounts(where: String, sort: [String!], limit: Int, offset: Int): CartDiscountQueryResult!
  productDiscount("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): ProductDiscount
  productDiscounts(where: String, sort: [String!], limit: Int, offset: Int): ProductDiscountQueryResult!
  product("""Queries for a product with specified SKU""" sku: String, """Queries for a product with specified [product variant key](https://docs.commercetools.com/api/projects/products#variant_key)""" variantKey: String, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Product
  products(where: String, sort: [String!], limit: Int, offset: Int, """Queries for products with specified SKUs""" skus: [String!]): ProductQueryResult!
  state("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): State
  states(where: String, sort: [String!], limit: Int, offset: Int): StateQueryResult!
  customer("""Queries a customer with specified email token""" emailToken: String, """Queries a customer with specified password token""" passwordToken: String, """Queries with specified ID""" id: String, """Queries with specified key""" key: String): Customer
  customers(where: String, sort: [String!], limit: Int, offset: Int): CustomerQueryResult!
  inventoryEntry(id: String!): InventoryEntry
  inventoryEntries(where: String, sort: [String!], limit: Int, offset: Int): InventoryEntryQueryResult!
  cart(id: String!): Cart
  carts(where: String, sort: [String!], limit: Int, offset: Int): CartQueryResult!
  customerActiveCart(customerId: String!): Cart
  message("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): Message
  messages(where: String, sort: [String!], limit: Int, offset: Int): MessageQueryResult!
  order("""Queries with specified ID""" id: String, orderNumber: String): Order
  orders(where: String, sort: [String!], limit: Int, offset: Int): OrderQueryResult!
  orderEdit("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): OrderEdit
  orderEdits(where: String, sort: [String!], limit: Int, offset: Int): OrderEditQueryResult!
  shoppingList("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
  payment("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): Payment
  payments(where: String, sort: [String!], limit: Int, offset: Int): PaymentQueryResult!
  productProjectionsSuggest(searchKeywords: [SearchKeywordArgument!]!, fuzzy: Boolean, limit: Int = 10, staged: Boolean = false): SuggestResult!
  project: ProjectProjection!
  store("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): Store
  stores(where: String, sort: [String!], limit: Int, offset: Int): StoreQueryResult!
  review("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): Review
  reviews(where: String, sort: [String!], limit: Int, offset: Int): ReviewQueryResult!
  subscription("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): CommercetoolsSubscription
  subscriptions(where: String, sort: [String!], limit: Int, offset: Int): CommercetoolsSubscriptionQueryResult!
  extension("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): Extension
  extensions(where: String, sort: [String!], limit: Int, offset: Int): ExtensionQueryResult!
  apiClient(id: String!): APIClientWithoutSecret
  apiClients(where: String, sort: [String!], limit: Int, offset: Int): APIClientWithoutSecretQueryResult!
  limits: ProjectCustomLimitsProjection!
  productProjectionSearch(locale: Locale, text: String, facets: [SearchFacetInput!] = [], filters: [SearchFilterInput!] = [], queryFilters: [SearchFilterInput!] = [], facetFilters: [SearchFilterInput!] = [], sorts: [String!] = [], limit: Int = 10, offset: Int = 0, fuzzy: Boolean = false, fuzzyLevel: Int, priceSelector: PriceSelectorInput, markMatchingVariant: Boolean = false, storeProjection: String, localeProjection: [Locale!], staged: Boolean = false): ProductProjectionSearchResult!
}
type QueryLimitsProjection {
  offset: Limit!
}
input RangeElementInput {
  from: String!
  to: String!
}
input RangeFacetInput {
  path: String!
  ranges: [RangeElementInput!]!
  alias: String
  countProducts: Boolean! = false
}
input RangeFilterInput {
  path: String!
  ranges: [RangeElementInput!]!
}
type RawCustomField {
  name: String!
  value: Json!
}
type RawProductAttribute {
  name: String!
  value: Json!
  attributeDefinition: AttributeDefinition
}
type RawProductSearchAttribute {
  name: String!
  value: Json!
}
type Reference {
  typeId: String!
  id: String!
}
type ReferenceAttributeDefinitionType implements AttributeDefinitionType {
  referenceTypeId: String!
  name: String!
}
input ReferenceInput {
  typeId: String!
  id: String!
}
type RefreshTokenLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type RefreshTokenLimitsProjection {
  total: RefreshTokenLimitWithCurrent!
}
"""Stores information about returns connected to this order."""
type ReturnInfo {
  items: [ReturnItem!]!
  returnTrackingId: String
  returnDate: DateTime
}
interface ReturnItem {
  type: String!
  id: String!
  quantity: Long!
  comment: String
  shipmentState: ReturnShipmentState!
  paymentState: ReturnPaymentState!
  lastModifiedAt: DateTime!
  createdAt: DateTime!
}
enum ReturnPaymentState {
  NotRefunded
  Refunded
  Initial
  NonRefundable
}
enum ReturnShipmentState {
  Unusable
  BackInStock
  Returned
  Advised
}
type Review implements Versioned {
  key: String
  uniquenessValue: String
  locale: Locale
  authorName: String
  title: String
  text: String
  targetRef: Reference
  target: ReviewTarget
  rating: Int
  stateRef: Reference
  state: State
  includedInStatistics: Boolean!
  customerRef: Reference
  customer: Customer
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type ReviewQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Review!]!
}
type ReviewRatingStatistics {
  averageRating: Float!
  highestRating: Int!
  lowestRating: Int!
  count: Long!
  ratingsDistribution: Json!
}
interface ReviewTarget {
  id: String!
}
enum RoundingMode {
  """[Round half down](https://en.wikipedia.org/wiki/Rounding#Round_half_down). Rounding mode used by, e.g., [Avalara Sales TaxII](https://help.avalara.com/kb/001/How_does_Rounding_with_SalesTaxII_work%3F)"""
  HalfDown
  """[Round half up](https://en.wikipedia.org/wiki/Rounding#Round_half_up)"""
  HalfUp
  """[Round half to even](https://en.wikipedia.org/wiki/Rounding#Round_half_to_even). Default rounding mode as used in IEEE 754 computing functions and operators."""
  HalfEven
}
input SearchFacetInput {
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  model: SearchFacetModelInput
  string: String
}
input SearchFacetModelInput {
  terms: TermsFacetInput
  value: ValueFacetInput
  range: RangeFacetInput
  tree: TreeFacetInput
  valueCount: ValueCountFacetInput
  missing: MissingFacetInput
}
"""
Search filter. It is represented as a string and has th same format as in REST API: "field:filter_criteria"
"""
scalar SearchFilter
input SearchFilterInput {
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  model: SearchFilterModelInput
  string: String
}
input SearchFilterModelInput {
  value: ValueFilterInput
  range: RangeFilterInput
  missing: MissingFilterInput
  exists: ExistsFilterInput
  tree: TreeFilterInput
}
type SearchIndexingConfiguration {
  products: SearchIndexingConfigurationValues
  orders: OrderSearchConfiguration
}
type SearchIndexingConfigurationValues {
  status: SearchIndexingStatus
  lastModifiedAt: DateTime
  lastModifiedBy: Initiator
}
enum SearchIndexingStatus {
  Activated
  Indexing
  Deactivated
}
type SearchKeyword {
  text: String!
  suggestTokenizer: SuggestTokenizer
}
input SearchKeywordArgument {
  searchKeyword: String!
  locale: Locale!
}
type SearchKeywordProductSearch {
  text: String!
  suggestTokenizer: SuggestTokenizerProductSearch
}
type SearchKeywords {
  locale: Locale!
  searchKeywords: [SearchKeyword!]!
}
type SearchKeywordsProductSearch {
  locale: Locale!
  searchKeywords: [SearchKeywordProductSearch!]!
}
type SearchLimitsProjection {
  maxTextSize: Limit!
}
"""Search sort"""
scalar SearchSort
type SetAttributeDefinitionType implements AttributeDefinitionType {
  elementType: AttributeDefinitionType!
  name: String!
}
enum ShipmentState {
  Delayed
  Backorder
  Partial
  Pending
  Ready
  Shipped
}
type ShippingInfo {
  shippingMethodName: String!
  price: Money!
  shippingRate: ShippingRate!
  taxRate: TaxRate
  deliveries: [Delivery!]!
  discountedPrice: DiscountedLineItemPrice
  taxedPrice: TaxedItemPrice
  shippingMethodState: ShippingMethodState!
  shippingMethod: ShippingMethod
  shippingMethodRef: Reference
  taxCategory: TaxCategory
  taxCategoryRef: Reference
}
type ShippingMethod implements Versioned {
  name: String!
  zoneRates: [ZoneRate!]!
  isDefault: Boolean!
  predicate: String
  key: String
  taxCategoryRef: Reference
  localizedDescriptionAllLocales: [LocalizedString!]
  localizedNameAllLocales: [LocalizedString!]
  localizedDescription("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  localizedName("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  taxCategory: TaxCategory
  custom: CustomFieldsType
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type ShippingMethodLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type ShippingMethodLimitsProjection {
  total: ShippingMethodLimitWithCurrent!
}
type ShippingMethodQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [ShippingMethod!]!
}
enum ShippingMethodState {
  """Either there is no predicate defined for the ShippingMethod or the given predicate matches the cart"""
  MatchesCart
  """The ShippingMethod predicate does not match the cart. Ordering this cart will fail with error ShippingMethodDoesNotMatchCart"""
  DoesNotMatchCart
}
"""A field to retrieve available shipping methods for a cart."""
interface ShippingMethodsByCartInterface {
  shippingMethodsByCart(id: String!): [ShippingMethod!]!
}
"""Shipping Rate"""
type ShippingRate {
  price: Money!
  freeAbove: Money
  isMatching: Boolean
  tiers: [ShippingRatePriceTier!]!
}
interface ShippingRateInput {
  type: String!
}
interface ShippingRateInputType {
  type: String!
}
interface ShippingRatePriceTier {
  type: String!
}
type ShoppingList implements Versioned {
  key: String
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  slug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]
  customerRef: Reference
  customer: Customer
  storeRef: KeyReference
  store: Store
  anonymousId: String
  lineItems: [ShoppingListLineItem!]!
  textLineItems: [TextLineItem!]!
  custom: CustomFieldsType
  deleteDaysAfterLastModification: Int
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type ShoppingListLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type ShoppingListLimitsProjection {
  lineItems: Limit!
  textLineItems: Limit!
  total: ShoppingListLimitWithCurrent!
}
type ShoppingListLineItem {
  id: String!
  productId: String!
  variantId: Int
  productTypeRef: Reference!
  productType: ProductTypeDefinition!
  quantity: Int!
  addedAt: DateTime!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  deactivatedAt: DateTime
  custom: CustomFieldsType
  productSlug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  productSlugAllLocales: [LocalizedString!]
  variant: ProductVariant
}
"""Fields to access shopping lists. Includes direct access to a single list and searching for shopping lists."""
interface ShoppingListQueryInterface {
  shoppingList("""Queries with specified ID""" id: String, """Queries with specified key""" key: String): ShoppingList
  shoppingLists(where: String, sort: [String!], limit: Int, offset: Int): ShoppingListQueryResult!
}
type ShoppingListQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [ShoppingList!]!
}
type ShoppingListsConfiguration {
  deleteDaysAfterLastModification: Int
}
enum StackingMode {
  """Don’t apply any more matching discounts after this one."""
  StopAfterThisDiscount
  """Default. Continue applying other matching discounts after applying this one."""
  Stacking
}
interface StagedOrderUpdateActionOutput {
  type: String!
}
"""[State](https://docs.commercetools.com/api/projects/states)"""
type State implements Versioned {
  id: String!
  version: Long!
  key: String
  type: StateType!
  roles: [StateRole!]!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  builtIn: Boolean!
  transitionsRef: [Reference!]
  transitions: [State!]
  initial: Boolean!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type StateQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [State!]!
}
enum StateRole {
  Return
  ReviewIncludedInStatistics
}
enum StateType {
  OrderState
  ProductState
  ReviewState
  PaymentState
  LineItemState
}
"""Stores allow defining different contexts for a project."""
type Store implements Versioned {
  id: String!
  version: Long!
  key: String!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]
  languages: [Locale!]
  distributionChannelsRef: [Reference!]!
  distributionChannels: [Channel!]!
  supplyChannelsRef: [Reference!]!
  supplyChannels: [Channel!]!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  custom: CustomFieldsType
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type StoreLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type StoreLimitsProjection {
  inventorySupplyChannels: Limit!
  productDistributionChannels: Limit!
  total: StoreLimitWithCurrent!
}
type StoreQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Store!]!
}
type SubRate {
  name: String!
  amount: Float!
}
enum SubscriptionHealthStatus {
  TemporaryError
  ConfigurationErrorDeliveryStopped
  ConfigurationError
  Healthy
}
type SuggestResult {
  searchKeywords: [SuggestResultEntry!]!
}
type SuggestResultEntry {
  locale: Locale!
  suggestions: [Suggestion!]!
}
interface SuggestTokenizer {
  type: String!
}
interface SuggestTokenizerProductSearch {
  type: String!
}
type Suggestion {
  text: String!
}
"""Stores information about order synchronization activities (like export or import)."""
type SyncInfo {
  channelRef: Reference!
  channel: Channel
  externalId: String
  syncedAt: DateTime!
}
enum TaxCalculationMode {
  """
  This calculation mode calculates the taxes on the unit price before multiplying with the quantity.
E.g. `($1.08 * 1.19 = $1.2852 -> $1.29 rounded) * 3 = $3.87`
  """
  UnitPriceLevel
  """
  Default. This calculation mode calculates the taxes after the unit price is multiplied with the quantity.
E.g. `($1.08 * 3 = $3.24) * 1.19 = $3.8556 -> $3.86 rounded`
  """
  LineItemLevel
}
"""Tax Categories define how products are to be taxed in different countries."""
type TaxCategory implements Versioned {
  name: String!
  description: String
  rates: [TaxRate!]!
  key: String
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type TaxCategoryLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type TaxCategoryLimitsProjection {
  total: TaxCategoryLimitWithCurrent!
}
type TaxCategoryQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [TaxCategory!]!
}
enum TaxMode {
  """No taxes are added to the cart."""
  Disabled
  """
  The tax amounts and the tax rates as well as the tax portions are set externally per ExternalTaxAmountDraft.
A cart with this tax mode can only be ordered if the cart itself and all line items, all custom line items and
the shipping method have an external tax amount and rate set
  """
  ExternalAmount
  """
  The tax rates are set externally per ExternalTaxRateDraft. A cart with this tax mode can only be ordered if all
line items, all custom line items and the shipping method have an external tax rate set. The totalNet and
totalGross as well as the taxPortions fields are calculated by the platform according to the taxRoundingMode.
  """
  External
  """
  The tax rates are selected by the platform from the TaxCategories based on the cart shipping address.
The totalNet and totalGross as well as the taxPortions fields are calculated by the platform according to the
taxRoundingMode.
  """
  Platform
}
"""
Represents the portions that sum up to the totalGross field of a TaxedPrice. The portions are calculated
from the TaxRates. If a tax rate has SubRates, they are used and can be identified by name. Tax portions
from line items that have the same rate and name will be accumulated to the same tax portion.
"""
type TaxPortion {
  rate: Float!
  amount: Money!
  name: String
}
type TaxRate {
  name: String!
  amount: Float!
  includedInPrice: Boolean!
  country: Country!
  state: String
  id: String
  subRates: [SubRate!]!
}
type TaxedItemPrice {
  totalNet: Money!
  totalGross: Money!
}
type TaxedPrice {
  totalNet: Money!
  totalGross: Money!
  taxPortions: [TaxPortion!]!
}
input TermsFacetInput {
  path: String!
  alias: String
  countProducts: Boolean! = false
}
type TextAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}
enum TextInputHint {
  SingleLine
  MultiLine
}
type TextLineItem {
  id: String!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  descriptionAllLocales: [LocalizedString!]
  quantity: Int!
  custom: CustomFieldsType
  addedAt: DateTime!
}
type TimeAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}
type TrackingData {
  trackingId: String
  carrier: String
  provider: String
  providerTransaction: String
  isReturn: Boolean!
}
type Transaction {
  id: String!
  timestamp: DateTime
  type: TransactionType
  amount: Money!
  interactionId: String
  state: TransactionState!
}
enum TransactionState {
  Failure
  Success
  Pending
  Initial
}
enum TransactionType {
  Chargeback
  Refund
  Charge
  CancelAuthorization
  Authorization
}
input TreeFacetInput {
  path: String!
  rootValues: [String!]!
  subTreeValues: [String!]!
  alias: String
  countProducts: Boolean! = false
}
input TreeFilterInput {
  path: String!
  rootValues: [String!]!
  subTreeValues: [String!]!
}
type Trigger {
  resourceTypeId: String!
  actions: [ActionType!]!
}
"""Types define the structure of custom fields which can be attached to different entities throughout the platform."""
type TypeDefinition implements Versioned {
  key: String!
  name("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  description("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  nameAllLocales: [LocalizedString!]!
  descriptionAllLocales: [LocalizedString!]
  resourceTypeIds: [String!]!
  fieldDefinitions("""
The names of the custom field definitions to include.

If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
""" includeNames: [String!], """
The names of the custom field definitions to exclude.

If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
""" excludeNames: [String!]): [FieldDefinition!]!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type TypeDefinitionQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [TypeDefinition!]!
}
type UserProvidedIdentifiers {
  key: String
  orderNumber: String
  customerNumber: String
  externalId: String
  sku: String
  slug("""String is defined for different locales. This argument specifies the desired locale.""" locale: Locale, """List of languages the client is able to understand, and which locale variant is preferred.""" acceptLanguage: [Locale!]): String
  slugAllLocales: [LocalizedString!]
}
input ValueCountFacetInput {
  path: String!
  alias: String
}
input ValueFacetInput {
  path: String!
  values: [String!]!
  alias: String
  countProducts: Boolean! = false
}
input ValueFilterInput {
  path: String!
  values: [String!]!
}
"""Versioned object have an ID and version and modification. Every update of this object changes it's version."""
interface Versioned {
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
"""YearMonth is a scalar value that represents an ISO8601 formatted year and month."""
scalar YearMonth
"""Zones allow defining ShippingRates for specific Locations."""
type Zone implements Versioned {
  name: String!
  key: String
  description: String
  locations: [Location!]!
  id: String!
  version: Long!
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: Initiator
  lastModifiedBy: Initiator
}
type ZoneLimitWithCurrent implements LimitWithCurrent {
  limit: Long
  current: Long!
}
type ZoneLimitsProjection {
  total: ZoneLimitWithCurrent!
}
type ZoneQueryResult {
  offset: Int!
  count: Int!
  total: Long!
  """BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#beta-features"""
  exists: Boolean!
  results: [Zone!]!
}
type ZoneRate {
  shippingRates: [ShippingRate!]!
  zoneRef: Reference
  zone: Zone
}
"""The `BigDecimal` scalar type represents signed fractional values with arbitrary precision."""
scalar BigDecimal
"""The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point)."""
scalar Float
"""The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1."""
scalar Long
