# Working with Service Workers

We're using Service Workers for two main purposes:

1. To cache out static and dynamic data feeds, to make them [available offline](https://developers.google.com/web/fundamentals/primers/service-workers/)
2. To run offline data sync.

To achieve the first point, we're using [Google Workbox](https://developers.google.com/web/tools/workbox).

## Making things happen

The service-worker source code for `vue-storefront` is pre-compiled with Babel presets and all is stored in an additional theme-specific Service Worker in `src/{themename}/service-worker/index.js`. This file is attached to `service-worker.js` generated by `sw-toolbox`.

After changing anything in `{themename}/service-worker/index.js`, despite you're in `yarn dev` auto  reloading mode, you need to do two things:

1. Recompile app (which regenerates service-worker):
   `yarn build`

2. Reload Service Worker in Dev Tools (in Chrome, just click **"Unregister"** and reload the page, and a new Service Worker will be installed).


![How to work with service-workers in Chrome](../images/chrome-dev-console.png)

## Custom service-worker rules using your theme

You can add your own service-worker rules to your theme using the `theme/service-worker/index.js` file. This file will be imported and extends the core service-worker rules in `@vue-storefront/core/service-worker/core-service-worker`.

```js
import { registerRoute } from 'workbox-routing'
import { CacheFirst } from 'workbox-strategies'
import { ExpirationPlugin } from 'workbox-expiration'

/*
Service worker extension:

The code will be merged with default Service Worker

Add your own Service worker code here:

import { registerRoute } from 'workbox-routing'
import { CacheFirst } from 'workbox-strategies'
import { ExpirationPlugin } from 'workbox-expiration'

const outputCache = new NetworkFirst({
  cacheName: 'vsf-output',
  plugins: [
    new ExpirationPlugin({
      maxEntries: 50,
      maxAgeSeconds: 60 * 60 * 24, // 1d
      purgeOnQuotaError: true
    })
  ]
})

registerRoute(
  /.+\.html$/,
  outputCache
)

registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'my-image-cache',
  })
)

registerRoute(
  /.+\.(css|js|png)$/,
  new NetworkFirst({
    cacheName: 'my-asset-cache',
  })
)
*/

```

## Communication with the app

The application can speak to the Service Worker using the event bus, and only doing so. Please take a look at `/core/lib/sw.js` where we have the following method:

```js
export function postMessage(payload) {
  if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
    // check if it's properly installed
    navigator.serviceWorker.controller.postMessage(payload);
    return false;
  } else {
    // no service workers supported push the queue manualy
    return true;
  }
}
```

It allows you to send data to the Service Worker. For example, when the order is placed (`/core/store/modules/checkout`):

```js
  /**
   * Add order to sync. queue
   * @param {Object} product data format for products is described in /doc/ElasticSearch data formats.md
   */
  [types.CHECKOUT_PLACE_ORDER] (state, order) {
    const ordersCollection = StorageManager.get('orders')
    const orderId = entities.uniqueEntityId(order) // timestamp as a order id is not the best we can do but it's enough
    order.id = orderId.toString()
    order.transmited = false
    order.created_at = new Date()
    order.updated_at = new Date()

    ordersCollection.setItem(orderId.toString(), order).catch((reason) => {
      console.error(reason) // it doesn't work on SSR
      sw.postMessage({ config: config, command: types.CHECKOUT_PROCESS_QUEUE }) // process checkout queue
      console.info('Order placed, orderId = ' + orderId)
    }) // populate cache
  },
```
