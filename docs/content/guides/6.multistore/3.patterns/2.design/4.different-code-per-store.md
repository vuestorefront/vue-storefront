---
title: Different markups for individual components
layout: default
navigation:
  icon: tabler:number-1-small
---

# Different Markups for Individual Components

## Prerequisites

Familiarity with [Tooling & Concepts → File-Based Inheritance](/guides/multistore/tooling-and-concepts/file-based-inheritance) is required to understand file override mechanisms and inheritance principles.

**What You’ll Learn**

::list{type="success"}
- How to safely modify the markup of individual components in a multibrand project without breaking their props interfaces
- How to handle breaking changes in component props with step-by-step workflows, including duplicating and modifying files
- Best practices for managing component markup customization to maintain consistency and avoid duplication
- How to implement these changes using examples in Next.js and Nuxt to adapt to specific frameworks
::

## Why Customize Component Markups?

In multibrand setups, different stores often require unique layouts or styling. Customization is necessary to ensure proper alignment with branding and design guidelines while sharing common functionalities across stores. For example:

- Store-specific customizations to match unique branding designs.
- Adjustments to the structure or layout of a component in one brand without affecting others.

Changing a component’s markup is a **structured process**, and this guide will walk you through **safe modifications** and scenarios where **breaking changes** are unavoidable.

## Safe Markup Changes Without Breaking Props

The most straightforward way to customize a component is by modifying **only its markup** while keeping its props interface unchanged. This ensures compatibility across the codebase and minimizes any disruption to dependent components or features.

### When to Use

- To rearrange the component structure.
- To adjust styling for specific stores or brands without altering the functionality.

### The Solution: Component Override

In cases where a specific store requires customization, you can override the component by duplicating and modifying it within that store's directory.

#### Example Workflow

1. **Duplicate** the component inside the store-specific directory.
2. **Modify** the duplicated component as per the store's requirements (e.g., layout, structure, or styles).

#### In Next.js

Here's how to override `AddToCartButton` for a specific store (`store-a`) in a Next.js project:

```tsx
// /apps/stores/store-a/storefront-unified-nextjs/components/decorated-price.tsx

import classNames from 'classnames';

import { useFormatter } from '@/hooks/use-formatter';
import type { SfProduct } from '@/types';

export interface ClassNameVariants {
   regular?: string;
   special?: string;
}

// Props remain unchanged
export interface DecoratedPriceProps {
   className?: string;
   classNameVariants?: ClassNameVariants;
   price: SfProduct['price'];
}

export default function DecoratedPrice({ className, classNameVariants, price, ...rest }: DecoratedPriceProps) {
  const { formatPrice } = useFormatter();

  const regular = price?.value ? formatPrice(price.value) : '';
  const special = price?.isDiscounted ? formatPrice(price!.regularPrice) : undefined;

  return (
    price && (
      <div className={classNames('flex items-baseline gap-x-2', className)} {...rest}>
        <span
          className={classNames('font-semibold', classNameVariants?.regular, {
          {/* Customized className for store-a */}
            'text-neutral-900': !special, // [!code --]
            'text-primary-700': !special, // [!code ++] 
            'text-secondary-700': special,
          })}
          data-testid="special-price"
        >
          {regular}
        </span>
        {special && (
          {/* Customized content for store-a */}
          <>// [!code ++]
             <span className="block text-red-700">Super offer!<span>// [!code ++] 
             <span
               className={classNames('font-normal text-neutral-500 line-through', classNameVariants?.special)}
               data-testid="regular-price"
             >
               {special}
             </span>
          </>// [!code ++] 
        )}
      </div>
    )
  );
}
```

#### In Nuxt

The process is similar in Nuxt. Here’s an example:

```vue
// /apps/stores/store-a/storefront-unified-nuxt/components/DecoratedPrice/DecoratedPrice.vue

<template>
  <div class="flex gap-x-2 items-baseline">
    <span
      data-testid="special-price"
      :class="[
        'font-semibold',
        classNameVariants?.regular,
        {
          <!-- Customized class for store-a -->
          'text-neutral-900': !special, // [!code --]
          'text-primary-700': !special, // [!code ++] 
          'text-secondary-700': special,
        },
      ]"
    >
      {{ regular }}
    </span>
     <!-- Customized content for store-a -->
    <span v-if="special" className="block text-red-700">Super offer!<span>// [!code ++] 
    <span
      v-if="special"
      data-testid="regular-price"
      :class="['font-normal text-neutral-500 line-through', classNameVariants?.special]"
    >
      {{ special }}
    </span>
  </div>
</template>

<script setup lang="ts">
// Props remain unchanged
defineProps<{
   className?: string;
   classNameVariants?: ClassNameVariants;
   regular: string;
   special?: string;
}>();
</script>
```

### Outcome

In both cases (Next.js and Nuxt), props remain untouched, ensuring compatibility with the rest of the application. Adjustments remain restricted to layout or presentation, avoiding unnecessary duplication or breaking changes to functionality.

## Breaking Changes in Component Markup

Some changes may require adjustments to the component’s **props interface**, meaning that the component is no longer compatible with its previous usage. These are referred to as **breaking changes** because they can potentially impact other parts of the application if not handled correctly.

### When to Use

- When introducing additional props for brand-specific requirements.
- When removing unused or deprecated props for cleaner, leaner implementations.
- When creating a fundamentally different component design unique to specific brands or stores.

### Example Workflow for Breaking Changes

#### Scenario 1: Adding Props

The `DecoratedPrice` requires a new prop `customText`, exclusively for `store-b`.

1. **Duplicate** the component for `store-b`.
2. **Modify the props interface** to include the new prop.
3. **Implement fallback behaviors** it's best to make new props as optional to ensure existing components using the old interface remain functional
4. **Modify components usage** update props passed to the changed component in other parts of your store that are using it

#### In Next.js

```tsx
// /apps/stores/store-b/storefront-unified-nextjs/components/decorated-price.tsx

import classNames from 'classnames';

import { useFormatter } from '@/hooks/use-formatter';
import type { SfProduct } from '@/types';

export interface ClassNameVariants {
  regular?: string;
  special?: string;
}

// Added new prop
export interface DecoratedPriceProps {
  className?: string;
  classNameVariants?: ClassNameVariants;
  price: SfProduct['price'];
  customText?: string; // [!code ++]
}

export default function DecoratedPrice({ className, classNameVariants, price, ...rest }: DecoratedPriceProps) { // [!code --]
export default function DecoratedPrice({ customText, className, classNameVariants, price, ...rest }: DecoratedPriceProps) { // [!code ++]
  const { formatPrice } = useFormatter();

  const regular = price?.value ? formatPrice(price.value) : '';
  const special = price?.isDiscounted ? formatPrice(price!.regularPrice) : undefined;

  return (
    price && (
      <div className={classNames('flex items-baseline gap-x-2', className)} {...rest}>
        {customText && <span className="text-center">{customText}</span>} // [!code ++]
        <span
          className={classNames('font-semibold', classNameVariants?.regular, {
            'text-neutral-900': !special,
            'text-secondary-700': special,
          })}
          data-testid="special-price"
        >
          {regular}
        </span>
        {special && (
          <span
            className={classNames('font-normal text-neutral-500 line-through', classNameVariants?.special)}
            data-testid="regular-price"
          >
            {special}
          </span>
        )}
      </div>
    )
  );
}
```

#### In Nuxt

```vue
// /apps/stores/store-b/storefront-unified-nuxt/components/DecoratedPrice/DecoratedPrice.vue

<template>
  <div class="flex gap-x-2 items-baseline">
    <span v-if="customText" class="text-center">{customText}</span> // [!code ++]
    <span
      data-testid="special-price"
      :class="[
        'font-semibold',
        classNameVariants?.regular,
        {
          'text-neutral-900': !special,
          'text-secondary-700': special,
        },
      ]"
    >
      {{ regular }}
    </span>
    <span
      v-if="special"
      data-testid="regular-price"
      :class="['font-normal text-neutral-500 line-through', classNameVariants?.special]"
    >
      {{ special }}
    </span>
  </div>
</template>

<script setup lang="ts">
// Added new prop
defineProps<{
   className?: string;
   classNameVariants?: ClassNameVariants;
   regular: string;
   special?: string;
   customText?: string; // [!code ++]
}>();
</script>
```

#### Scenario 2: Removing Props

In this scenario, we'll demonstrate removing the `classNameVariants` prop because the component no longer uses it, explicitly for `store-c`.

1. **Duplicate** the component for `store-c`.
2. **Modify the props interface** the safest solution is to make the prop optional and mark it as `@deprecated` for Typescript. You can safely remove the prop completely after making sure that usage of the component is updated across the `store-c`
3. **Modify components usage** update props passed to the changed component in other parts of your store that are using it

#### In Next.js

```tsx
// apps/stores/store-c/storefront-unified-nextjs/components/decorated-price.tsx

import classNames from 'classnames';

import { useFormatter } from '@/hooks/use-formatter';
import type { SfProduct } from '@/types';

export interface ClassNameVariants {
  regular?: string;
  special?: string;
}

// Setting prop as deprecated
export interface DecoratedPriceProps {
  className?: string;
   // [!code ++:4]
   /**
    * @deprecated
    */
  classNameVariants: ClassNameVariants; // [!code --]
  classNameVariants?: ClassNameVariants; // [!code ++]
  price: SfProduct['price'];
}

export default function DecoratedPrice({ className, classNameVariants, price, ...rest }: DecoratedPriceProps) { // [!code --]
export default function DecoratedPrice({ className, price, ...rest }: DecoratedPriceProps) { // [!code ++]
  const { formatPrice } = useFormatter();

  const regular = price?.value ? formatPrice(price.value) : '';
  const special = price?.isDiscounted ? formatPrice(price!.regularPrice) : undefined;

  return (
    price && (
      <div className={classNames('flex items-baseline gap-x-2', className)} {...rest}>
        <span
          className={classNames('font-semibold', classNameVariants.regular, { // [!code --]
          className={classNames('font-semibold', { // [!code ++]
            'text-neutral-900': !special,
            'text-secondary-700': special,
          })}
          data-testid="special-price"
        >
          {regular}
        </span>
        {special && (
          <span
            className={classNames('font-normal text-neutral-500 line-through', classNameVariants.special)} // [!code --]
            className={classNames('font-normal text-neutral-500 line-through')} // [!code ++]
            data-testid="regular-price"
          >
            {special}
          </span>
        )}
      </div>
    )
  );
}
```

#### In Nuxt

```ts
// /apps/stores/store-c/storefront-unified-nuxt/components/DecoratedPrice/DecoratedPrice.vue

<template>
  <div class="flex gap-x-2 items-baseline">
    <span
      data-testid="special-price"
      :class="[
        'font-semibold',
        classNameVariants.regular, // [!code --]
        {
          'text-neutral-900': !special,
          'text-secondary-700': special,
        },
      ]"
    >
      {{ regular }}
    </span>
    <span
      v-if="special"
      data-testid="regular-price"
      :class="['font-normal text-neutral-500 line-through', classNameVariants.special]"  // [!code --]
      :class="['font-normal text-neutral-500 line-through']" // [!code ++]
    >
      {{ special }}
    </span>
  </div>
</template>

<script setup lang="ts">
// Setting prop as deprecated
defineProps<{
   className?: string;
  // [!code ++:4]
  /**
   * @deprecated it won't be used for store-c
   */
   classNameVariants: ClassNameVariants; // [!code --]
   classNameVariants?: ClassNameVariants; // [!code ++]
   regular: string;
   special?: string;
}>();
</script>
```

### Restructuring the Parent Store

::tip
Parent Store can be a direct parent store or a base application that all stores inherit from.
::

Another approach to handling component customization is restructuring  parent store component. This involves removing specialized props from the parent component and adding them only to the specific stores that need them.

#### When to Use

- When a prop is only used by specific stores and not universally required
- To reduce complexity in the parent component
- To make inheritance more explicit and maintainable
- When you want to avoid unnecessary props in stores that don't need them

Instead of adding specialized props to the root component that all stores inherit, you can remove them from the root and add them only where needed.

#### Example Workflow

1. **Remove** the specialized props from the parent store component
2. **Add** the props only to the store specific component
3. **Update** implementations of the changed component in specific store

#### In Next.js

First, remove the `classNameVariants` prop from the root component:

```tsx
// /apps/storefront-unified-nextjs/components/decorated-price.tsx

import classNames from 'classnames';

import { useFormatter } from '@/hooks/use-formatter';
import type { SfProduct } from '@/types';

export interface ClassNameVariants {
  regular?: string;
  special?: string;
}

// Remove prop from parent
export interface DecoratedPriceProps {
  className?: string;
  classNameVariants?: ClassNameVariants; // [!code --]
  price: SfProduct['price'];
}

export default function DecoratedPrice({ className, classNameVariants, price, ...rest }: DecoratedPriceProps) { // [!code --]
export default function DecoratedPrice({ className, price, ...rest }: DecoratedPriceProps) { // [!code ++]
  const { formatPrice } = useFormatter();

  const regular = price?.value ? formatPrice(price.value) : '';
  const special = price?.isDiscounted ? formatPrice(price!.regularPrice) : undefined;

  return (
    price && (
      <div className={classNames('flex items-baseline gap-x-2', className)} {...rest}>
        <span
          className={classNames('font-semibold', classNameVariants.regular, { // [!code --]
          className={classNames('font-semibold', { // [!code ++]
            'text-neutral-900': !special,
            'text-secondary-700': special,
          })}
          data-testid="special-price"
        >
          {regular}
        </span>
        {special && (
          <span
            className={classNames('font-normal text-neutral-500 line-through', classNameVariants.special)} // [!code --]
            className={classNames('font-normal text-neutral-500 line-through')} // [!code ++]
            data-testid="regular-price"
          >
            {special}
          </span>
        )}
      </div>
    )
  );
}
```

Then, add the prop only to stores that need it (e.g., `store-a`):

```tsx
// /apps/stores/store-a/storefront-unified-nextjs/components/decorated-price.tsx

import classNames from 'classnames';

import { useFormatter } from '@/hooks/use-formatter';
import type { SfProduct } from '@/types';

export interface ClassNameVariants {
  regular?: string;
  special?: string;
}

// Added prop to store-a
export interface DecoratedPriceProps {
  className?: string;
  classNameVariants: ClassNameVariants; // [!code ++]
  price: SfProduct['price'];
}

export default function DecoratedPrice({ className, price, ...rest }: DecoratedPriceProps) { // [!code --]
export default function DecoratedPrice({ className, classNameVariants, price, ...rest }: DecoratedPriceProps) { // [!code ++]
  const { formatPrice } = useFormatter();

  const regular = price?.value ? formatPrice(price.value) : '';
  const special = price?.isDiscounted ? formatPrice(price!.regularPrice) : undefined;

  return (
    price && (
      <div className={classNames('flex items-baseline gap-x-2', className)} {...rest}>
        <span
          className={classNames('font-semibold', classNameVariants.regular, { // [!code ++]
          className={classNames('font-semibold', { // [!code --]
            'text-neutral-900': !special,
            'text-secondary-700': special,
          })}
          data-testid="special-price"
        >
          {regular}
        </span>
        {special && (
          <span
            className={classNames('font-normal text-neutral-500 line-through')} // [!code --]
            className={classNames('font-normal text-neutral-500 line-through', classNameVariants.special)} // [!code ++]
            data-testid="regular-price"
          >
            {special}
          </span>
        )}
      </div>
    )
  );
}
```

#### In Nuxt

Similarly, remove the prop from the parent store component:

```ts
// /apps/storefront-unified-nuxt/components/DecoratedPrice/DecoratedPrice.vue

<template>
  <div class="flex gap-x-2 items-baseline">
    <span
      data-testid="special-price"
      :class="[
        'font-semibold',
        classNameVariants?.regular, // [!code --]
        {
          'text-neutral-900': !special,
          'text-secondary-700': special,
        },
      ]"
    >
      {{ regular }}
    </span>
    <span
      v-if="special"
      data-testid="regular-price"
      :class="['font-normal text-neutral-500 line-through', classNameVariants?.special]"  // [!code --]
      :class="['font-normal text-neutral-500 line-through']" // [!code ++]
    >
      {{ special }}
    </span>
  </div>
</template>

<script setup lang="ts">
// Prop is removed from the parent component
defineProps<{
   className?: string;
   classNameVariants?: ClassNameVariants; // [!code --]
   regular: string;
   special?: string;
}>();
</script>
```

And add it to specific stores that need it:

```ts
// /apps/stores/store-a/storefront-unified-nuxt/components/DecoratedPrice/DecoratedPrice.vue

<template>
  <div class="flex gap-x-2 items-baseline">
    <span
      data-testid="special-price"
      :class="[
        'font-semibold',
        classNameVariants.regular, // [!code ++]
        {
          'text-neutral-900': !special,
          'text-secondary-700': special,
        },
      ]"
    >
      {{ regular }}
    </span>
    <span
      v-if="special"
      data-testid="regular-price"
      :class="['font-normal text-neutral-500 line-through']" // [!code --]
      :class="['font-normal text-neutral-500 line-through', classNameVariants.special]"  // [!code ++]
    >
      {{ special }}
    </span>
  </div>
</template>

<script setup lang="ts">
// Prop is added to the store-a component
defineProps<{
   className?: string;
   classNameVariants: ClassNameVariants; // [!code ++]
   regular: string;
   special?: string;
}>();
</script>
```

### Benefits and Considerations

#### Benefits:

- Cleaner, more minimal parent components
- Better encapsulation of store-specific features
- Reduced complexity in inheritance chains
- Clearer separation of concerns

#### Considerations:

- Requires changes to the base component, which affects all inheriting stores
- Need to update component usages in stores that need the specialized prop
- May require more upfront planning but leads to cleaner architecture in the long term

This approach is particularly useful when you've identified that certain features are only needed by a subset of stores, and you want to avoid unnecessary complexity in your base components.

## Testing and Verifying Breaking Changes

While introducing breaking changes, follow these strategies to ensure stability:

1. **Test Locally:**
    - Verify that dependent stores or components remain functional.
    - Use `yarn dev` to observe changes in real-time.

2. **Document Changes Clearly:**
    - Update relevant guides or internal documentation pointing out the new props and their usage.

3. **Run Integration Tests:**
    - Use `yarn test:integration:pw` to validate functionality across the inheritance chain.

4. **Communicate with Teams:**
    - Breaking changes should be coordinated with development teams to avoid unnecessary disruptions.

## Best Practices for Customizing Component Markups

#### Do:
- Keep props interfaces intact when possible.
- Leverage duplication and overrides for brand-specific customizations.
- Document all breaking changes thoroughly.

#### Avoid:
- Excessive overrides that increase maintenance costs.
- Introducing breaking changes without backward compatibility.
- Skipping tests after applying updates.

## Conclusion

Customizing individual components in a **multibrand setup** can effectively address brand-specific requirements while maintaining maintainable code. Follow these steps to confidently adjust component markups while avoiding breaking changes whenever possible.
