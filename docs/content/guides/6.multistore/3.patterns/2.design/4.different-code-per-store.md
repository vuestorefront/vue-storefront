---
title: Different markups for individual components
layout: default
navigation:
  icon: tabler:number-1-small
---

# Different Markups for Individual Components

> **Prerequisite:** Familiarity with [Tooling & Concepts → File-Based Inheritance](../2.file-based-inheritance.md) is required to understand file override mechanisms and inheritance principles.

**What You’ll Learn**

::list{type="success"}
- How to safely modify the markup of individual components in a multibrand project without breaking their props interfaces
- How to handle breaking changes in component props with step-by-step workflows, including duplicating and modifying files
- Best practices for managing component markup customization to maintain consistency and avoid duplication
- How to implement these changes using examples in Next.js and Nuxt to adapt to specific frameworks
::

## Why Customize Component Markups?

In multibrand setups, different brands often require unique layouts or styling, creating the need to adjust component markups. For example:

- Store-specific customizations to align with unique branding designs.
- Adaptations to existing components for layout or structural requirements in one brand, while using the same components unchanged in others.

Changing a component’s markup is a **structured process**, and this guide will walk you through both **safe modifications** and situations where **breaking changes** to props are unavoidable.

## Safe Markup Changes Without Breaking Props

The safest way to customize a component is to modify **only its markup** while keeping its props interface unchanged. This avoids downstream issues and ensures compatibility with the rest of your application.

### When to Use

- To rearrange component structure.
- To update styles for specific brands.

### The Solution: Component Override

In cases where you need to do changes in a component for a specific store's needs without modifying the original component, you can simply replace the original component. 

#### Example Workflow

1. Duplicate the component inside the specific store directory.
2. Modify the duplicated component as needed.

#### In Next.js

Here is how you can override the `ExampleComponent` component for a specific store in Next.js:

```tsx
// /apps/stores/store-a/storefront-unified-nextjs/components/example-component.tsx

interface ExampleComponentProps {
  title: string;
  imageSrc: string;
}

export default function ExampleComponent({ title, imageSrc }: ExampleComponentProps) {
  return (
    <div className="store-a example-component"> {/* Customized className for store-a */}
      <img src={imageSrc} alt={title} />
      <h2>{title}</h2>
      {/* Customized content for store-a */}
    </div>
  );
}
```

#### In Nuxt

The process is similar in Nuxt:

```vue
// /apps/stores/store-a/storefront-unified-nuxt/components/example-component.vue

<template>
  <div class="store-a example-component">
    <!-- Customized className for store-a -->
    <img :src="imageSrc" :alt="title" />
    <h2>{{ title }}</h2>
    <!-- Customized content for store-a -->
  </div>
</template>

<script setup>
defineProps({
  title: {
    type: String,
    required: true,
  },
  imageSrc: {
    type: String,
    required: true,
  },
});
</script>

```

### Outcome

In both examples, the underlying props remain untouched, so there are no changes required to the application logic or API calls. The customization is limited to the layout or visual presentation.

## Breaking Changes in Component Markup

In some scenarios, customizations require changes to a component’s **props interface**. This type of change is referred to as **breaking changes**, as it may no longer be compatible with existing props usage.

### When to Use

- To introduce new props for specific brand requirements.
- To remove outdated or unused props for simpler brand-specific implementations.

### Example Workflow

Imagine the `ExampleComponent` needs an additional prop, `customSubtitle`, exclusively for a specific brand.

#### **Step 1: Clone the Original Component**

Duplicate the `ExampleComponent` into the specific store directory.

For **Next.js**:

```tsx
// /apps/stores/store-a/storefront-unified-nextjs/components/example-component.tsx

interface ExampleComponentProps {
  title: string;
  imageSrc: string;
  customSubtitle: string; // New prop added for store-a
}

export default function ExampleComponent({ title, imageSrc, customSubtitle }: ExampleComponentProps) {
  return (
    <div className="store-a example-component">
      <img src={imageSrc} alt={title} />
      <h2>{title}</h2>
      {customSubtitle && <p>{customSubtitle}</p>} {/* New conditional rendering */}
    </div>
  );
}
```

For **Nuxt**:

```vue
// /apps/stores/store-a/storefront-unified-nuxt/components/example-component.vue

<template>
  <div class="store-a example-component">
    <img :src="imageSrc" :alt="title" />
    <h2>{{ title }}</h2>
    <p v-if="customSubtitle">{{ customSubtitle }}</p>
  </div>
</template>

<script setup>
defineProps({
  title: {
    type: String,
    required: true,
  },
  imageSrc: {
    type: String,
    required: true,
  },
  customSubtitle: { // New prop added for store-a
    type: String,
    required: true,
  },
});
</script>
```

#### **Step 2: Update Store-Specific Usage**

Identify places where the component is used in the store and adjust prop values accordingly.
Update the store-specific pages to account for the new prop.

In **Next.js**

```tsx
// /apps/stores/store-a/storefront-unified-next/app/example-page/page.tsx

import ExampleComponent from "@/components/example-component";

export default function StoreAPage() {
  return (
    <ExampleComponent 
      title="Store A Title" 
      imageSrc="/path/to/image.jpg" 
      customSubtitle="Custom Subtitle for Store A" 
    />
  );
}
```

In **Nuxt**

```vue
// /apps/stores/store-a/storefront-unified-nuxt/pages/example-page.vue

<template>
  <ExampleComponent 
    title="Store A Title" 
    :imageSrc="'/path/to/image.jpg'" 
    customSubtitle="Custom Subtitle for Store A" 
  />
</template>

<script setup>
import ExampleComponent from "@/components/example-component";
</script>
```

### Outcome

In this updated example using `ExampleComponent`, breaking changes to the component markup allow developers to manage props changes in a contained way, limiting the impact to only the brand that requires the new functionality. Other brands can continue using the original props without modification.

## Best Practices

### Wrapping Components for Easier Overrides

To minimize duplication and provide greater flexibility, consider designing pages with **smaller, composable components**. This allows you to customize only the necessary parts when brand-specific adjustments are needed.

### Limit Breaking Changes

Avoid breaking changes whenever possible. If a component’s props must change, ensure that:

1. It’s **limited to a single store**.
2. Changes are clearly documented.
3. They don’t negatively impact shared or global components used by other stores.

### Consistency Across Components

Maintain consistency of shared props between stores unless a breaking change is **absolutely necessary**.

### Document Changes Thoroughly

If a breaking change occurs, document:
- The updated props interface.
- Stores impacted by the change.
- Steps developers should follow during future updates.

## Conclusion

Customizing individual components in a **multibrand setup** can effectively address brand-specific requirements while maintaining maintainable code. Follow these steps to confidently adjust component markups while avoiding breaking changes whenever possible.

For related concepts, check out:

- [Tooling & Concepts → File-Based Inheritance](../2.file-based-inheritance.md)
- [Patterns → Managing the Stores](../3.managing-the-stores.md)
