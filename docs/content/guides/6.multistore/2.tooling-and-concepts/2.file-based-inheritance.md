---
title: File-based inheritance
layout: default
navigation:
  icon: tabler:number-1-small
---

# File-based inheritance

File-based inheritance is a powerful feature in Alokai that enables efficient code sharing and customization across multiple stores. It allows you to maintain a consistent codebase while customizing specific parts of the codebase for different brands or regions.

**What you'll learn**

::list{type="success"}
- Understanding file-based inheritance and its core concepts
- Different types of stores and when to use them
- How to create and manage stores using the CLI
- How store hierarchy and file overrides work
- How stores are composed and built
- Best practices and common pitfalls to avoid
::

## Core Concepts

### What is File-Based Inheritance?

File-based inheritance is a system that allows stores to inherit and customize code from base applications and other stores. This approach enables:

1. **Code Reuse**
   - Stores inherit all files from base applications by default
   - Common functionality is maintained in one place
   - Changes in base code automatically propagate to all stores

2. **Selective Customization**
   - Stores can override specific files when needed
   - Only override what's different, inherit everything else
   - Maintain the same file path structure for overrides

3. **Hierarchical Inheritance**
   - Stores can inherit from other stores (ancestors)
   - Multiple levels of inheritance are supported
   - More specific overrides take precedence over general ones

For example, if you want to customize a product card component:
```bash
# Original component in base app
apps/storefront-unified-nextjs/components/product-card.tsx

# Override in a specific store
apps/stores/brand-a/storefront-unified-nextjs/components/product-card.tsx
```

The store will use its own version of `product-card.tsx`, while inheriting all other files from the base application.

Every store inherits from these base applications:
```bash
apps/storefront-unified-nextjs/  # Next.js Storefront
apps/storefront-unified-nuxt/    # Nuxt Storefront
apps/storefront-middleware/      # Middleware
apps/playwright/                 # E2E tests
```

:::tip How it works
1. When a file is requested, the CLI looks for it in the current store
2. If not found, it checks ancestor stores in reverse order (closest first)
3. Finally, it looks in the base applications
4. The first file found is used
:::

### Project Structure

Every project starts with a single store called `default`. 

:::tip
There is nothing special within the `default` store, it is treated just like any other store. You can rename it to whatever you want.
:::

Every store inherits from these base applications:
```bash
apps/storefront-unified-nextjs/  # Next.js Storefront
apps/storefront-unified-nuxt/    # Nuxt Storefront
apps/storefront-middleware/      # Middleware
apps/playwright/                 # E2E tests
```

### Store Types

Alokai supports two types of stores to accommodate different business needs:

#### Direct Stores
- Stores that are meant to be deployed and run
- Have their own build output in `.out/<store-id>`
- Can override files from ancestor stores
- Can add store-specific files
- Example: An actual online store for a specific brand or region

#### Inheritance-Only Stores
- Stores that are never deployed
- Act as shared configuration/code providers for their descendant stores
- Used to group common overrides for a set of related stores
- No build output in `.out` directory
- Example: A regional configuration store containing shared theme and regulations for all stores in that region

## Creating New Stores

To create a new store, you can use the `storefront-cli` to create a new store in the `stores` directory:

```bash
./node_modules/.bin/storefront-cli store add
```

or 

```bash
yarn store add
```

:::warning
Although you can use the storefront-cli with `npx storefront-cli store` we recommend using the `yarn store` as it will use the correct version of the storefront-cli, which is installed in the project.
:::

The CLI will guide you through the process and allow you to:
- Choose the store id
- Choose the parent store - you can decide if the new store should be a child of another store
- Choose the store type (direct or inheritance-only)

:::info
For more information on the `storefront-cli` and the commands available, please refer to the [storefront-cli reference](/guides/multistore/tooling-and-concepts/cli-reference).
:::

## Managing Store Hierarchy

### Store Structure

Simple hierarchy example:
```bash
apps/
├── storefront-unified-nextjs/     # Base shared code
└── stores/
    ├── brand-a/                   # Direct store
    │   └── storefront-unified-nextjs/
    └── brand-b/                   # Another direct store
        └── storefront-unified-nextjs/
```

Complex hierarchy example with multiple brands and regions:
```bash
apps/
├── storefront-unified-nextjs/          # Base shared code
└── stores/
    ├── fashion-brand/                  # Fashion brand stores
    │   ├── storefront-unified-nextjs/  # Shared fashion brand customizations
    │   └── stores/
    │       ├── us-store/              # US fashion store
    │       └── eu-store/              # EU fashion store
    └── sports-brand/                   # Sports brand stores
        ├── storefront-unified-nextjs/  # Shared sports brand customizations
        └── stores/
            ├── us-store/              # US sports store
            └── eu-store/              # EU sports store
```

#### When to use complex hierarchies
Complex hierarchies make sense when you have multiple brands or store families that need different:
- Visual themes
- Features and functionality
- Business logic
- Regional customizations

In the example above, `fashion-brand` and `sports-brand` can have completely different:
- UI components and styling
- Customer journey flows
- Product presentation
- Regional adaptations

:::warning Keep it Simple
Only create inheritance levels when you need to share code between multiple stores. If you have just one brand or store family, keep everything in the base shared code (`apps/storefront-unified-nextjs/`).
:::

### Moving Stores

You can reorganize your store hierarchy using the `store move` command:

```bash
yarn store move
```

This command allows you to:
- Move a store to a different parent
- Restructure your store hierarchy
- Group related stores under a new inheritance-only store

:::tip Common Use Case
A common scenario is when you have several stores and want to group them under a new inheritance-only store to share common customizations:

1. Create a new inheritance-only store:
```bash
yarn store add  # Create 'us-region' as inheritance-only
```

2. Move existing stores under it:
```bash
yarn store move  # Move 'brand-a' and 'brand-b' under 'us-region'
```

This allows you to introduce shared customizations for all US stores while maintaining their individual deployments.
:::

:::warning
Moving a store will update its inheritance chain. Make sure to test your application after moving stores to ensure all customizations are still working as expected.
:::

### File Override System

To override a file:

1. Create the same file path in your store's directory
2. Copy the original file (optional starting point)
3. Make your modifications

Example:
```bash
# Original file
apps/storefront-unified-nextjs/components/header.tsx

# Override in your store
apps/stores/brand-a/storefront-unified-nextjs/components/header.tsx
```

:::warning
Always maintain the same directory structure when overriding files to ensure proper inheritance.
:::

## Technical Implementation

### TypeScript Configuration

The CLI automatically generates a `tsconfig.json` for each store. It's worth noting that the following configuration ensures the store can import files from the base storefront, ancestor stores, and the store itself:

```json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./*", "../../../storefront-unified-nextjs/*"],
      "@sf-modules/*": ["./sf-modules/*", "../../../storefront-unified-nextjs/sf-modules/*"]
    },
    "rootDirs": ["./", "../../../storefront-unified-nextjs"]
  }
}
```

:::warning Do not modify tsconfig.json
The system automatically manages TypeScript configuration. Manual changes may break inheritance.
:::

### Change Detection

During the development process, the CLI:
- Automatically detects file changes in parent stores
- Propagates changes down the inheritance chain
- Respects overrides in child stores

:::tip
You can read more about the change detection in the [Using a local environment](/guides/multistore/tooling-and-concepts/development/local-environment) guide.
:::

## Store Composition and Build Output

### How Stores are Composed

When building stores, the system:
1. Collects all files from the base apps (`apps/storefront-unified-nextjs/`, etc.)
2. Applies overrides from parent stores in order
3. Finally applies the store's own overrides
4. Outputs the composed store to `.out/<store-id>/`

For example, with this hierarchy:
```bash
apps/
├── storefront-unified-nextjs/     # Base shared code
│   ├── components/
│   │   └── ProductCard.tsx       # Original component
└── stores/
    └── fashion-brand/
        ├── storefront-unified-nextjs/
        │   └── components/
        │       └── ProductCard.tsx   # Override 1
        └── stores/
            └── us-store/
                └── storefront-unified-nextjs/
                    └── components/
                        └── ProductCard.tsx   # Override 2
```

The build process for `us-store` would:
1. Start with base files from `apps/storefront-unified-nextjs/`
2. Apply overrides from `fashion-brand`
3. Apply overrides from `us-store`
4. Output to `.out/us-store/`

### Build Output Structure

Each direct store is built into its own directory:
```bash
.out/
├── fashion-brand/
│   ├── storefront-unified-nextjs/   # Composed Next.js app
│   ├── storefront-middleware/       # Composed middleware
│   └── playwright/                 # Composed tests
└── us-store/
    ├── storefront-unified-nextjs/   # Composed Next.js app
    ├── storefront-middleware/       # Composed middleware
    └── playwright/                 # Composed tests
```

#### Inheritance-Only Stores
Inheritance-only stores are not built into the `.out` directory because:
- They are used only for sharing code with descendant stores
- They don't have their own deployment or runtime
- They serve as configuration templates for their descendant stores

For example, if `eu-region` is an inheritance-only store with descendant stores `fr-store` and `de-store`, only `fr-store` and `de-store` will appear in the `.out` directory. Any code or configuration in `eu-region` will be inherited by its descendants but `eu-region` itself won't be built.

:::info File Selection
The system always selects the most specific override in the inheritance chain. If a file is overridden at multiple levels, the closest override to the current store takes precedence.
:::

### Special Files

Some files receive special treatment during composition:

- `package.json`: Cannot be overridden by the store. It is copied from the root apps with updated store-specific name.
- `tsconfig.json`: Automatically generated for each store, based on the `tsconfig.json` in the root apps.

## Best Practices

1. **Minimize Overrides**
- Only override files when necessary
- Consider creating shared components in parent stores
- Use configuration files for simple customizations

2. **Maintain Clear Structure**
- Follow consistent directory organization
- Document store relationships
- Keep inheritance chains shallow when possible

3. **Testing**
- Test changes across the entire inheritance chain
- Verify overrides don't break parent functionality
- Include tests for store-specific features

## Common Pitfalls

1. **Incorrect File Placement**
   - Always place files within app-specific directories
   - Maintain consistent paths across stores

2. **Breaking Changes**
   - Consider the impact on child stores when modifying shared code
   - Test changes thoroughly across the inheritance chain

3. **Deep Inheritance**
   - Avoid deep inheritance chains (more than 3 levels)
   - Consider flattening the structure if maintenance becomes difficult

4. **Special File Handling**
   - `package.json`: 
     - Do not create this file within store directories
     - The CLI automatically generates it in `.out` directory during build
     - Add all dependencies to the root app's `package.json` (e.g., `apps/storefront-unified-nextjs/package.json`)
   - `tsconfig.json`:
     - Do not modify this file within store directories
     - The CLI automatically generates and manages it
     - Manual changes may break the inheritance system

::card{title="Next: Development - Managing the stores" icon="tabler:number-2-small" }

#description
TODO

#cta
:::docs-button{to="/guides/multistore/tooling-and-concepts/managing-the-stores"}
Next
:::
::
