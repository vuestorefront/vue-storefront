---
title: How to Make Sub-path Routing
layout: default
navigation:
  icon: tabler:number-1-small
---

# How to Make Sub-path Routing


Sub-path routing allows you to serve different store configurations from the same Alokai deployment using URL paths. This approach is ideal when you need to maintain multiple stores with different configurations but want to manage them from a single codebase.

::info
This guide focuses on implementing multi-store functionality through URL paths (like `/electronics`, `/apparel`). If domain-based separation is sufficient for your use case (like `electronics.example.com`, `apparel.example.com`), the [multibrand feature](https://docs.alokai.com/guides/multistore/tooling-and-concepts) is the preferred approach.
::

## Overview

Sub-path routing in Alokai uses the [Config Switcher extension](https://docs.alokai.com/middleware/guides/config-switcher) with the header strategy. This allows your Middleware to dynamically select the appropriate configuration based on which store the user is browsing.

For example, with this setup you could have:
- `/en/electronics` - Electronics store with its specific configuration
- `/en/apparel` - Apparel store with different products, styling, and configuration

All of this is served from a single Frontend deployment.

## Setting Up the Middleware

The first step is to configure your Middleware to support different configurations using the Config Switcher extension.

::tip Config Switcher Documentation
This section provides a brief overview of setting up Config Switcher. For complete documentation, refer to the [Config Switcher guide](https://docs.alokai.com/middleware/guides/config-switcher).
::

Create a Config Switcher extension for your integration:

```ts
// apps/storefront-middleware/integrations/<integration-name>/extensions/configSwitcher.ts
import { createConfigSwitcherExtension } from '@alokai/connect/config-switcher';
import type { MiddlewareConfig } from '@vsf-enterprise/<integration>-api';

export const configSwitcherExtension = createConfigSwitcherExtension<MiddlewareConfig>({
  // Config switcher options - specify only what's different for each store
  configuration: {
    apparel: {
      api: {
        baseSiteId: 'apparel',
        catalogId: 'apparelProductCatalog',
      },
    },
    electronics: {
      api: {
        baseSiteId: 'electronics',
        catalogId: 'electronicsProductCatalog',
      },
    },
  },
});
```

Then add this extension to your integration configuration:

```ts
// apps/storefront-middleware/integrations/<integration-name>/config.ts
import { configSwitcherExtension } from './extensions/configSwitcher';

export default {
  integrations: {
    <integration-name>: {
      // Base configuration shared across all stores
      configuration: {
        // ...
      },
      extensions: (predefinedExtensions) => [
        ...predefinedExtensions,
        configSwitcherExtension,
      ]
    }
  }
};
```

## Customizing Store Appearance with CSS Variables

To create distinct visual identities for each store, you can define CSS variables that change based on the store config ID. This is a powerful way to maintain a consistent component library while applying different themes.

::tabs{:titles='["Next.js", "Nuxt"]'}

#tab-1
In your Next.js app, add custom CSS variables in your global styles:

```scss
// apps/storefront-unified-nextjs/app/[locale]/globals.scss
@tailwind base;
@tailwind components;
@tailwind utilities;

// Base styles...

// Electronics store theme
.electronics {
  --colors-primary-50: 45 249 255;
  --colors-primary-100: 233 243 255;
  --colors-primary-200: 200 224 255;
  --colors-primary-300: 166 204 255;
  --colors-primary-400: 110 161 255;
  --colors-primary-500: 51 117 255;
  --colors-primary-600: 46 106 230;
  --colors-primary-700: 38 78 191;
  --colors-primary-800: 29 63 153;
  --colors-primary-900: 176 196 244;
}

// Apparel store theme (different color scheme)
.apparel {
  --colors-primary-50: 243 254 249;
  --colors-primary-100: 224 247 235;
  --colors-primary-200: 187 235 210;
  --colors-primary-300: 135 216 177;
  --colors-primary-400: 77 192 140;
  --colors-primary-500: 45 165 116;
  --colors-primary-600: 34 134 95;
  --colors-primary-700: 31 110 80;
  --colors-primary-800: 30 86 65;
  --colors-primary-900: 23 64 49;
}
```

#tab-2
In your Nuxt app, add custom CSS variables in your style.scss:

```scss
// apps/storefront-unified-nuxt/assets/style.scss
@tailwind base;
@tailwind components;
@tailwind utilities;

// Base styles...

// Electronics store theme
.electronics {
  --colors-primary-50: 45 249 255;
  --colors-primary-100: 233 243 255;
  --colors-primary-200: 200 224 255;
  --colors-primary-300: 166 204 255;
  --colors-primary-400: 110 161 255;
  --colors-primary-500: 51 117 255;
  --colors-primary-600: 46 106 230;
  --colors-primary-700: 38 78 191;
  --colors-primary-800: 29 63 153;
  --colors-primary-900: 176 196 244;
}

// Apparel store theme (different color scheme)
.apparel {
  --colors-primary-50: 243 254 249;
  --colors-primary-100: 224 247 235;
  --colors-primary-200: 187 235 210;
  --colors-primary-300: 135 216 177;
  --colors-primary-400: 77 192 140;
  --colors-primary-500: 45 165 116;
  --colors-primary-600: 34 134 95;
  --colors-primary-700: 31 110 80;
  --colors-primary-800: 30 86 65;
  --colors-primary-900: 23 64 49;
}
```
::

::info
For more information on using CSS variables with Tailwind, see the [Tailwind CSS documentation](https://v3.tailwindcss.com/docs/customizing-colors#using-css-variables).
::

## Setting Up the Storefront

Now you need to configure your Storefront to send the appropriate config ID to the Middleware based on the current URL path.

::tabs{:titles='["Next.js", "Nuxt"]'}

#tab-1
In your Next.js SDK configuration, implement the `getConfigSwitcherHeader` function:

```ts
// apps/storefront-unified-nextjs/sdk/config.ts
import { defineSdkConfig, getPathnameFromRequestHeaders } from '@vue-storefront/next';
import type { UnifiedEndpoints } from 'storefront-middleware/types';

function getConfigSwitcherHeader(baseHeaders: Record<string, string>) {
  const pathname =
    typeof window !== 'undefined' ? window.location.pathname : getPathnameFromRequestHeaders(baseHeaders);
  
  // Determine the config ID based on URL path
  return pathname?.includes('/electronics') ? 'electronics' : 'apparel';
}

export function getSdkConfig() {
  return defineSdkConfig(({ buildModule, config, getRequestHeaders, middlewareModule }) => ({
    unified: buildModule(middlewareModule<UnifiedEndpoints>, {
      apiUrl: `${config.apiUrl}/commerce/unified`,
      defaultRequestConfig: {
        getConfigSwitcherHeader,
        headers: getRequestHeaders,
      },
      // ... other config
    }),
    // ... other modules
  }));
}
```

#tab-2
In your Nuxt SDK configuration, define a reusable `getConfigSwitcherHeader` function:

```ts
// apps/storefront-unified-nuxt/sdk.config.ts
import type { CommerceEndpoints, UnifiedCmsEndpoints, UnifiedEndpoints } from 'storefront-middleware/types';

export default defineSdkConfig(({ buildModule, config, getRequestHeaders, middlewareModule }) => {
  const route = useRoute();
  
  // Create a reusable function for determining the config ID
  function getConfigSwitcherHeader() {
    return route.path.includes('/electronics') ? 'electronics' : 'apparel';
  }
  
  return {
    // Unified commerce module
    unified: buildModule(middlewareModule<UnifiedEndpoints>, {
      apiUrl: `${config.apiUrl}/commerce/unified`,
      defaultRequestConfig: {
        getConfigSwitcherHeader,
        headers: getRequestHeaders(),
      },
      // ... other config
    }),
    // ... other modules
  };
});
```
::

## Updating the File Structure for Path Routing

To enable path-based routing, you need to restructure your application to include a dynamic `[configId]` parameter in the route. This allows you to access the store identifier directly from the URL.

::tabs{:titles='["Next.js", "Nuxt"]'}

#tab-1
For Next.js apps using the App Router, update your file structure:

```bash
apps/storefront-unified-nextjs/app/
├── [locale]/                 # Language parameter
│   ├── [configId]/           # Store identifier parameter
│   │   ├── (default)/        # Routes for all stores
│   │   │   ├── page.tsx      # Home page
│   │   │   ├── cart/         # Cart pages
│   │   │   ├── checkout/     # Checkout pages
│   │   │   └── products/     # Product pages
│   │   ├── (electronics)/    # Electronics-specific routes
│   │   │   └── some-page/    # Page name
│   │   ├── (apparel)/        # Apparel-specific routes
│   │   │   └── another-page/ # Apparel-specific home
│   │   └── layout.tsx        # Apply store-specific class
```

#tab-2
For Nuxt apps, update your file structure:

```bash
apps/storefront-unified-nuxt/pages/
├── [configId]/              # Store identifier parameter
│   ├── index.vue            # Home page
│   ├── cart/                # Cart pages
│   │   └── index.vue
│   ├── checkout/            # Checkout pages
│   │   └── index.vue
│   ├── products/            # Product pages
│   │   ├── index.vue
│   │   └── [id].vue
│   ├── some-electronics-page.vue # Electronics-specific page
│   └── some-apparel-page.vue     # Apparel-specific page
```
::

This structure enables routes like:
- `/en/electronics` - Electronics store home
- `/en/apparel` - Apparel store home
- `/en/electronics/category` - PLP in the electronics store
- `/en/apparel/category` - PLP in the apparel store

## Updating Internal Links

::warning Update Internal Links
After setting up the path routing structure, you must update all internal links in your application to include the appropriate configId parameter. This is crucial to maintain proper navigation within each store and prevent users from accidentally switching between stores when clicking links.
::

Make sure that all your internal links and navigation components preserve the store context by including the current configId in the URLs. This applies to:

- Navigation menus
- Product links
- Category links
- Cart and checkout flows
- Footer links
- Breadcrumbs
- Any other internal navigation elements

Without this, users might unexpectedly switch between stores while browsing your site.

## Applying Store-Specific Styling

Now that you have CSS variables defined for each store, you need to apply the store identifier as a CSS class to enable the different styles.

::tabs{:titles='["Next.js", "Nuxt"]'}

#tab-1
In your Next.js layout, apply the configId as a class:

```tsx
// apps/storefront-unified-nextjs/app/[locale]/[configId]/layout.tsx
import { PropsWithChildren } from 'react';

interface LayoutProps extends PropsWithChildren {
  params: {
    configId: string;
  };
}

export default function Layout({ children, params: { configId } }: LayoutProps) {
  return (
    <div className={configId}>
      {children}
    </div>
  );
}
```

#tab-2
In your Nuxt app.vue, apply the configId as a class:

```vue
// apps/storefront-unified-nuxt/app.vue
<template>
  <Body :class="['font-body', route.params.configId]" />
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>

<script setup lang="ts">
const route = useRoute();
</script>
```
::

## Styling Components for Different Stores

With the store identifier applied as a class, you can now customize components with store-specific styles. You'll need to update your Tailwind configuration to support this.

::tabs{:titles='["Next.js", "Nuxt"]'}

#tab-1
First, update your Tailwind config:

```ts
// packages-end-user/tailwind-config/src/nextjs.ts
import { tailwindConfig } from "@storefront-ui/react/tailwind-config";
import type { Config } from "tailwindcss";
import plugin from "tailwindcss/plugin";

const config: Config = {
  // ...
  plugins: [
    // ...
    plugin(({ addVariant }) => {
      // Add variant for electronics store
      addVariant("electronics", ".electronics &");
      // Add variant for apparel store
      addVariant("apparel", ".apparel &");
    }),
  ],
  // ...
};
export default config;
```

Then use these variants (`electronics:`, `apparel:` etc.) in your components:

```tsx
// apps/storefront-unified-nextjs/components/navigations/navbar-top.tsx
export default function NavbarTop({ children, className, filled }: NavbarTopProps) {
  return (
    <header
      className={classNames(
        'sticky top-0 z-40 flex h-14 bg-primary-800 electronics:!bg-primary-600 apparel:!bg-primary-400 md:-top-5 md:h-20 md:pt-2.5',
        // other classes...
      )}
      data-testid="navbar-top"
    >
      {/* Component content */}
    </header>
  );
}
```

#tab-2
First, update your Tailwind config:

```ts
// packages-end-user/tailwind-config/src/nuxt.ts
import type { Config } from "tailwindcss";
import plugin from "tailwindcss/plugin";

export default {
  // ...
  plugins: [
    // ...
    plugin(({ addVariant }) => {
      // Add variant for electronics store
      addVariant("electronics", ".electronics &");
      // Add variant for apparel store
      addVariant("apparel", ".apparel &");
    }),
  ],
  // ...
} as Config;
```

Then use these variants (`electronics:`, `apparel:` etc.) in your components:

```vue
// apps/storefront-unified-nuxt/components/ui/NavbarTop/NavbarTop.vue
<template>
  <header
    :class="[
      'h-14 md:h-20 flex z-40 sticky top-0 md:-top-5 md:pt-2.5 md:shadow-md',
      { 'bg-primary-700 electronics:bg-primary-500 apparel:bg-primary-300 text-white': filled },
      // other classes...
    ]"
    data-testid="navbar-top"
  >
    <!-- Component content -->
  </header>
</template>
```
::

## Conditional Components

There are two main approaches to handling store-specific components:

### Approach 1: Different Versions of the Same Component

This approach is useful when you need different variations of a component based on the store, such as announcement bars or featured sections with store-specific content.

::tabs{:titles='["Next.js", "Nuxt"]'}

#tab-1
```tsx
// apps/storefront-unified-nextjs/components/announcement-bar.tsx
import { ApparelAnnouncementBar } from '@/components/store-apparel/announcement-bar';
import { ElectronicsAnnouncementBar } from '@/components/store-electronics/announcement-bar';

interface AnnouncementBarProps {
  configId: string;
}

function AnnouncementBar({ configId }: AnnouncementBarProps) {
  const StoreComponent = {
    apparel: ApparelAnnouncementBar,
    electronics: ElectronicsAnnouncementBar,
  }[configId];

  return StoreComponent ? <StoreComponent /> : null;
}

// Usage in a page or layout:
export default function Layout({ children, params: { configId } }: LayoutProps) {
  return (
    <div className={configId}>
      <AnnouncementBar configId={configId} />
      {children}
    </div>
  );
}
```

#tab-2
```vue
<!-- apps/storefront-unified-nuxt/components/AnnouncementBar.vue -->
<template>
  <component :is="StoreComponent" v-if="StoreComponent" />
</template>

<script setup lang="ts">
const props = defineProps<{
  configId: string;
}>();

const AnnouncementBarElectronics = resolveComponent('StoreElectronicsAnnouncementBar');
const AnnouncementBarApparel = resolveComponent('StoreApparelAnnouncementBar');
const AnnouncementBar = computed(
  () =>
    ({
      electronics: AnnouncementBarElectronics,
      apparel: AnnouncementBarApparel,
    })[configId.value],
);
</script>

<!-- Usage in a page or layout: -->
<template>
  <div>
    <AnnouncementBar :config-id="configId" />
    <slot />
  </div>
</template>
```
::

### Approach 2: Conditional Rendering Based on Store

This approach is useful when certain components should only appear in specific stores, such as store-specific features or promotional sections.

::tabs{:titles='["Next.js", "Nuxt"]'}

#tab-1
```tsx
// apps/storefront-unified-nextjs/app/[locale]/[configId]/(default)/page.tsx
import { ElectronicsPromo } from '@/components/store-electronics/promo';
import { ApparelSeasonalBanner } from '@/components/store-apparel/seasonal-banner';

interface HomePageProps {
  params: {
    configId: string;
  };
}

export default function HomePage({ params: { configId } }: HomePageProps) {
  return (
    <div>
      <h1>Welcome to our store</h1>
      
      {/* Show component only for specific store */}
      {configId === 'electronics' && (
        <ElectronicsPromo />
      )}
      
      {/* Common content for all stores */}
      <div>
        {/* ... */}
      </div>
    </div>
  );
}
```

#tab-2
```vue
<!-- apps/storefront-unified-nuxt/pages/[configId]/index.vue -->
<template>
  <div>
    <h1>Welcome to our store</h1>
    
    <!-- Show component only for specific store -->
    <StoreElectronicsPromo v-if="configId === 'electronics'" />
    
    <!-- Common content for all stores -->
    <div>
      <!-- ... -->
    </div>
  </div>
</template>

<script setup lang="ts">
const route = useRoute();
const configId = computed(() => route.params.configId as string);
</script>
```
::

Choose the appropriate approach based on your needs:
::list{type="success"}
- Use Approach 1 (Different Versions) when components serve the same purpose but need store-specific implementations
- Use Approach 2 (Conditional Rendering) when components are unique to specific stores
- For components that are mostly the same but have minor differences, consider using props or slots instead of creating separate components
::

## Creating Store-Specific Pages

Some pages might only exist for specific stores. Here's how to implement this for each framework:

::tabs{:titles='["Next.js", "Nuxt"]'}

#tab-1
For Next.js, use route groups with the store name, and check the configId parameter:

```tsx
// apps/storefront-unified-nextjs/app/[locale]/[configId]/(electronics)/layout.tsx
import { notFound } from 'next/navigation';
import { PropsWithChildren } from 'react';

interface ElectronicsLayoutProps extends PropsWithChildren {
  params: {
    configId: string;
  };
}

export default function ElectronicsLayout({ children, params }: ElectronicsLayoutProps) {
  // Only render for electronics store
  if (params.configId !== 'electronics') {
    notFound();
  }

  return <div>{children}</div>;
}
```

This ensures that pages within the (electronics) [route group](https://nextjs.org/docs/app/building-your-application/routing/route-groups) are only accessible when the configId is `electronics`.

#tab-2
For Nuxt, use middleware in the store-specific page:

```vue
// apps/storefront-unified-nuxt/pages/[configId]/some-electronics-page.vue
<template>
  <div>
    <NuxtLayout name="default">
      <div>Hello from electronics page</div>
    </NuxtLayout>
  </div>
</template>

<script setup lang="ts">
definePageMeta({
  layout: false,
  middleware: (route) => {
    if (route.params.configId !== 'electronics') {
      return navigateTo('/');
    }
  },
});
</script>
```

This redirects users to the home page if they try to access the electronics-specific page from a different store.
::

## Summary

Sub-path routing in Alokai enables you to:

1. Serve multiple stores from a single codebase and deployment
2. Customize each store's appearance through CSS variables
3. Apply store-specific styles using Tailwind variants
4. Conditionally render components based on the store
5. Create store-specific pages

This approach is particularly useful when you need different store configurations that share the same core functionality but need to be accessed via different URL paths rather than domains.

::warning Consider Your Requirements
The path routing approach described in this guide deploys a single Frontend codebase that serves all stores. All files are shared between stores, which can be efficient but may increase complexity as you customize more aspects of each store. If path-based routing isn't a business requirement, consider using the [multibrand feature](https://docs.alokai.com/guides/multistore/tooling-and-concepts) instead, which provides more robust separation between stores.
::
